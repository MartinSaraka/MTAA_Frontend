{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport * as base64 from 'base64-js';\nimport { defineCustomEventTarget } from 'event-target-shim';\nimport MessageEvent from \"./MessageEvent\";\nimport RTCDataChannelEvent from \"./RTCDataChannelEvent\";\nimport EventEmitter from \"./EventEmitter\";\nvar WebRTCModule = NativeModules.WebRTCModule;\nvar DATA_CHANNEL_EVENTS = ['open', 'message', 'bufferedamountlow', 'closing', 'close', 'error'];\n\nvar RTCDataChannel = function (_defineCustomEventTar) {\n  _inherits(RTCDataChannel, _defineCustomEventTar);\n\n  var _super = _createSuper(RTCDataChannel);\n\n  function RTCDataChannel(info) {\n    var _this;\n\n    _classCallCheck(this, RTCDataChannel);\n\n    _this = _super.call(this);\n\n    _defineProperty(_assertThisInitialized(_this), \"_peerConnectionId\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_reactTag\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_id\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_label\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_maxPacketLifeTime\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_maxRetransmits\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_negotiated\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_ordered\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_protocol\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_readyState\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_subscriptions\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"binaryType\", 'arraybuffer');\n\n    _defineProperty(_assertThisInitialized(_this), \"bufferedAmount\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"bufferedAmountLowThreshold\", 0);\n\n    _this._peerConnectionId = info.peerConnectionId;\n    _this._reactTag = info.reactTag;\n    _this._label = info.label;\n    _this._id = info.id === -1 ? null : info.id;\n    _this._ordered = Boolean(info.ordered);\n    _this._maxPacketLifeTime = info.maxPacketLifeTime;\n    _this._maxRetransmits = info.maxRetransmits;\n    _this._protocol = info.protocol || '';\n    _this._negotiated = Boolean(info.negotiated);\n    _this._readyState = info.readyState;\n\n    _this._registerEvents();\n\n    return _this;\n  }\n\n  _createClass(RTCDataChannel, [{\n    key: \"label\",\n    get: function get() {\n      return this._label;\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n  }, {\n    key: \"ordered\",\n    get: function get() {\n      return this._ordered;\n    }\n  }, {\n    key: \"maxPacketLifeTime\",\n    get: function get() {\n      return this._maxPacketLifeTime;\n    }\n  }, {\n    key: \"maxRetransmits\",\n    get: function get() {\n      return this._maxRetransmits;\n    }\n  }, {\n    key: \"protocol\",\n    get: function get() {\n      return this._protocol;\n    }\n  }, {\n    key: \"negotiated\",\n    get: function get() {\n      return this._negotiated;\n    }\n  }, {\n    key: \"readyState\",\n    get: function get() {\n      return this._readyState;\n    }\n  }, {\n    key: \"send\",\n    value: function send(data) {\n      if (typeof data === 'string') {\n        WebRTCModule.dataChannelSend(this._peerConnectionId, this._reactTag, data, 'text');\n        return;\n      }\n\n      if (ArrayBuffer.isView(data)) {\n        data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n      } else if (data instanceof ArrayBuffer) {\n        data = new Uint8Array(data);\n      } else {\n        throw new TypeError('Data must be either string, ArrayBuffer, or ArrayBufferView');\n      }\n\n      WebRTCModule.dataChannelSend(this._peerConnectionId, this._reactTag, base64.fromByteArray(data), 'binary');\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this._readyState === 'closing' || this._readyState === 'closed') {\n        return;\n      }\n\n      WebRTCModule.dataChannelClose(this._peerConnectionId, this._reactTag);\n    }\n  }, {\n    key: \"_unregisterEvents\",\n    value: function _unregisterEvents() {\n      this._subscriptions.forEach(function (e) {\n        return e.remove();\n      });\n\n      this._subscriptions = [];\n    }\n  }, {\n    key: \"_registerEvents\",\n    value: function _registerEvents() {\n      var _this2 = this;\n\n      this._subscriptions = [EventEmitter.addListener('dataChannelStateChanged', function (ev) {\n        if (ev.reactTag !== _this2._reactTag) {\n          return;\n        }\n\n        _this2._readyState = ev.state;\n\n        if (_this2._id === null && ev.id !== -1) {\n          _this2._id = ev.id;\n        }\n\n        if (_this2._readyState === 'open') {\n          _this2.dispatchEvent(new RTCDataChannelEvent('open', {\n            channel: _this2\n          }));\n        } else if (_this2._readyState === 'closing') {\n          _this2.dispatchEvent(new RTCDataChannelEvent('closing', {\n            channel: _this2\n          }));\n        } else if (_this2._readyState === 'closed') {\n          _this2.dispatchEvent(new RTCDataChannelEvent('close', {\n            channel: _this2\n          }));\n\n          _this2._unregisterEvents();\n\n          WebRTCModule.dataChannelDispose(_this2._peerConnectionId, _this2._reactTag);\n        }\n      }), EventEmitter.addListener('dataChannelReceiveMessage', function (ev) {\n        if (ev.reactTag !== _this2._reactTag) {\n          return;\n        }\n\n        var data = ev.data;\n\n        if (ev.type === 'binary') {\n          data = base64.toByteArray(ev.data).buffer;\n        }\n\n        _this2.dispatchEvent(new MessageEvent('message', {\n          data: data\n        }));\n      })];\n    }\n  }]);\n\n  return RTCDataChannel;\n}(defineCustomEventTarget.apply(void 0, DATA_CHANNEL_EVENTS));\n\nexport { RTCDataChannel as default };","map":{"version":3,"sources":["RTCDataChannel.ts"],"names":["WebRTCModule","DATA_CHANNEL_EVENTS","defineCustomEventTarget","constructor","info","Boolean","label","id","ordered","maxPacketLifeTime","maxRetransmits","protocol","negotiated","readyState","send","ArrayBuffer","data","base64","close","_unregisterEvents","e","_registerEvents","ev","channel"],"mappings":"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","sourcesContent":["\nimport { NativeModules } from 'react-native';\nimport * as base64 from 'base64-js';\nimport { defineCustomEventTarget } from 'event-target-shim';\nimport MessageEvent from './MessageEvent';\nimport RTCDataChannelEvent from './RTCDataChannelEvent';\nimport EventEmitter from './EventEmitter';\n\nconst { WebRTCModule } = NativeModules;\n\ntype RTCDataChannelState = 'connecting' | 'open' | 'closing' | 'closed';\n\nconst DATA_CHANNEL_EVENTS = ['open', 'message', 'bufferedamountlow', 'closing', 'close', 'error'];\n\nexport default class RTCDataChannel extends defineCustomEventTarget(...DATA_CHANNEL_EVENTS) {\n    _peerConnectionId: number;\n    _reactTag: string;\n    _id: number;\n    _label: string;\n    _maxPacketLifeTime?: number;\n    _maxRetransmits?: number;\n    _negotiated: boolean;\n    _ordered: boolean;\n    _protocol: string;\n    _readyState: RTCDataChannelState;\n    _subscriptions: Array<any> = [];\n\n    binaryType: string = 'arraybuffer'; // we only support 'arraybuffer'\n    bufferedAmount: number = 0;\n    bufferedAmountLowThreshold: number = 0;\n\n    constructor(info) {\n        super();\n\n        this._peerConnectionId = info.peerConnectionId;\n        this._reactTag = info.reactTag;\n\n        this._label = info.label;\n        this._id = info.id === -1 ? null : info.id; // null until negotiated.\n        this._ordered = Boolean(info.ordered);\n        this._maxPacketLifeTime = info.maxPacketLifeTime;\n        this._maxRetransmits = info.maxRetransmits;\n        this._protocol = info.protocol || '';\n        this._negotiated = Boolean(info.negotiated);\n        this._readyState = info.readyState;\n\n        this._registerEvents();\n    }\n\n    get label(): string {\n        return this._label;\n    }\n\n    get id(): number {\n        return this._id;\n    }\n\n    get ordered(): boolean {\n        return this._ordered;\n    }\n\n    get maxPacketLifeTime(): number | undefined {\n        return this._maxPacketLifeTime;\n    }\n\n    get maxRetransmits(): number | undefined {\n        return this._maxRetransmits;\n    }\n\n    get protocol(): string {\n        return this._protocol;\n    }\n\n    get negotiated(): boolean {\n        return this._negotiated;\n    }\n\n    get readyState(): string {\n        return this._readyState;\n    }\n\n    send(data: string | ArrayBuffer | ArrayBufferView) {\n        if (typeof data === 'string') {\n            WebRTCModule.dataChannelSend(this._peerConnectionId, this._reactTag, data, 'text');\n            return;\n        }\n\n        // Safely convert the buffer object to an Uint8Array for base64-encoding\n        if (ArrayBuffer.isView(data)) {\n            data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n        } else if (data instanceof ArrayBuffer) {\n            data = new Uint8Array(data);\n        } else {\n            throw new TypeError('Data must be either string, ArrayBuffer, or ArrayBufferView');\n        }\n        WebRTCModule.dataChannelSend(this._peerConnectionId, this._reactTag, base64.fromByteArray(data as Uint8Array), 'binary');\n    }\n\n    close() {\n        if (this._readyState === 'closing' || this._readyState === 'closed') {\n            return;\n        }\n        WebRTCModule.dataChannelClose(this._peerConnectionId, this._reactTag);\n    }\n\n    _unregisterEvents() {\n        this._subscriptions.forEach(e => e.remove());\n        this._subscriptions = [];\n    }\n\n    _registerEvents() {\n        this._subscriptions = [\n            EventEmitter.addListener('dataChannelStateChanged', ev => {\n                if (ev.reactTag !== this._reactTag) {\n                    return;\n                }\n                this._readyState = ev.state;\n                if (this._id === null && ev.id !== -1) {\n                    this._id = ev.id;\n                }\n                if (this._readyState === 'open') {\n                    // @ts-ignore\n                    this.dispatchEvent(new RTCDataChannelEvent('open', { channel: this }));\n                } else if (this._readyState === 'closing') {\n                    // @ts-ignore\n                    this.dispatchEvent(new RTCDataChannelEvent('closing', { channel: this }));\n                } else if (this._readyState === 'closed') {\n                    // @ts-ignore\n                    this.dispatchEvent(new RTCDataChannelEvent('close', { channel: this }));\n                    this._unregisterEvents();\n                    WebRTCModule.dataChannelDispose(this._peerConnectionId, this._reactTag);\n                }\n            }),\n            EventEmitter.addListener('dataChannelReceiveMessage', ev => {\n                if (ev.reactTag !== this._reactTag) {\n                    return;\n                }\n                let data = ev.data;\n                if (ev.type === 'binary') {\n                    data = base64.toByteArray(ev.data).buffer;\n                }\n                // @ts-ignore\n                this.dispatchEvent(new MessageEvent('message', { data }));\n            })\n        ];\n    }\n}\n"]},"metadata":{},"sourceType":"module"}
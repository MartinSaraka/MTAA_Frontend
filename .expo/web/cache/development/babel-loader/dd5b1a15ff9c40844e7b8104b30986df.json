{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { defineCustomEventTarget } from 'event-target-shim';\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport MediaStream from \"./MediaStream\";\nimport MediaStreamEvent from \"./MediaStreamEvent\";\nimport MediaStreamTrackEvent from \"./MediaStreamTrackEvent\";\nimport RTCDataChannel from \"./RTCDataChannel\";\nimport RTCDataChannelEvent from \"./RTCDataChannelEvent\";\nimport RTCSessionDescription from \"./RTCSessionDescription\";\nimport RTCIceCandidate from \"./RTCIceCandidate\";\nimport RTCIceCandidateEvent from \"./RTCIceCandidateEvent\";\nimport RTCEvent from \"./RTCEvent\";\nimport * as RTCUtil from \"./RTCUtil\";\nimport EventEmitter from \"./EventEmitter\";\nvar WebRTCModule = NativeModules.WebRTCModule;\nvar PEER_CONNECTION_EVENTS = ['connectionstatechange', 'icecandidate', 'icecandidateerror', 'iceconnectionstatechange', 'icegatheringstatechange', 'negotiationneeded', 'signalingstatechange', 'datachannel', 'addstream', 'removestream'];\nvar nextPeerConnectionId = 0;\n\nvar RTCPeerConnection = function (_defineCustomEventTar) {\n  _inherits(RTCPeerConnection, _defineCustomEventTar);\n\n  var _super = _createSuper(RTCPeerConnection);\n\n  function RTCPeerConnection(configuration) {\n    var _this;\n\n    _classCallCheck(this, RTCPeerConnection);\n\n    _this = _super.call(this);\n\n    _defineProperty(_assertThisInitialized(_this), \"localDescription\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"remoteDescription\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"signalingState\", 'stable');\n\n    _defineProperty(_assertThisInitialized(_this), \"iceGatheringState\", 'new');\n\n    _defineProperty(_assertThisInitialized(_this), \"connectionState\", 'new');\n\n    _defineProperty(_assertThisInitialized(_this), \"iceConnectionState\", 'new');\n\n    _defineProperty(_assertThisInitialized(_this), \"_peerConnectionId\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_localStreams\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"_remoteStreams\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"_subscriptions\", []);\n\n    _this._peerConnectionId = nextPeerConnectionId++;\n    WebRTCModule.peerConnectionInit(configuration, _this._peerConnectionId);\n\n    _this._registerEvents();\n\n    return _this;\n  }\n\n  _createClass(RTCPeerConnection, [{\n    key: \"addStream\",\n    value: function addStream(stream) {\n      var index = this._localStreams.indexOf(stream);\n\n      if (index !== -1) {\n        return;\n      }\n\n      WebRTCModule.peerConnectionAddStream(stream._reactTag, this._peerConnectionId);\n\n      this._localStreams.push(stream);\n    }\n  }, {\n    key: \"removeStream\",\n    value: function removeStream(stream) {\n      var index = this._localStreams.indexOf(stream);\n\n      if (index === -1) {\n        return;\n      }\n\n      this._localStreams.splice(index, 1);\n\n      WebRTCModule.peerConnectionRemoveStream(stream._reactTag, this._peerConnectionId);\n    }\n  }, {\n    key: \"createOffer\",\n    value: function createOffer(options) {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        WebRTCModule.peerConnectionCreateOffer(_this2._peerConnectionId, RTCUtil.normalizeOfferAnswerOptions(options), function (successful, data) {\n          if (successful) {\n            resolve(data);\n          } else {\n            reject(data);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"createAnswer\",\n    value: function createAnswer() {\n      var _this3 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return new Promise(function (resolve, reject) {\n        WebRTCModule.peerConnectionCreateAnswer(_this3._peerConnectionId, RTCUtil.normalizeOfferAnswerOptions(options), function (successful, data) {\n          if (successful) {\n            resolve(data);\n          } else {\n            reject(data);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"setConfiguration\",\n    value: function setConfiguration(configuration) {\n      WebRTCModule.peerConnectionSetConfiguration(configuration, this._peerConnectionId);\n    }\n  }, {\n    key: \"setLocalDescription\",\n    value: function setLocalDescription(sessionDescription) {\n      var desc, newSdp;\n      return _regeneratorRuntime.async(function setLocalDescription$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              desc = sessionDescription ? sessionDescription.toJSON ? sessionDescription.toJSON() : sessionDescription : null;\n              _context.next = 3;\n              return _regeneratorRuntime.awrap(WebRTCModule.peerConnectionSetLocalDescription(this._peerConnectionId, desc));\n\n            case 3:\n              newSdp = _context.sent;\n              this.localDescription = new RTCSessionDescription(newSdp);\n\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"setRemoteDescription\",\n    value: function setRemoteDescription(sessionDescription) {\n      var _this4 = this;\n\n      return new Promise(function (resolve, reject) {\n        WebRTCModule.peerConnectionSetRemoteDescription(sessionDescription.toJSON ? sessionDescription.toJSON() : sessionDescription, _this4._peerConnectionId, function (successful, data) {\n          if (successful) {\n            _this4.remoteDescription = new RTCSessionDescription(data);\n            resolve();\n          } else {\n            reject(data);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"addIceCandidate\",\n    value: function addIceCandidate(candidate) {\n      var newSdp;\n      return _regeneratorRuntime.async(function addIceCandidate$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(!candidate || !candidate.candidate)) {\n                _context2.next = 2;\n                break;\n              }\n\n              return _context2.abrupt(\"return\");\n\n            case 2:\n              _context2.next = 4;\n              return _regeneratorRuntime.awrap(WebRTCModule.peerConnectionAddICECandidate(this._peerConnectionId, candidate.toJSON ? candidate.toJSON() : candidate));\n\n            case 4:\n              newSdp = _context2.sent;\n              this.remoteDescription = new RTCSessionDescription(newSdp);\n\n            case 6:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"getStats\",\n    value: function getStats() {\n      return WebRTCModule.peerConnectionGetStats(this._peerConnectionId).then(function (data) {\n        return new Map(JSON.parse(data));\n      });\n    }\n  }, {\n    key: \"getLocalStreams\",\n    value: function getLocalStreams() {\n      return this._localStreams.slice();\n    }\n  }, {\n    key: \"getRemoteStreams\",\n    value: function getRemoteStreams() {\n      return this._remoteStreams.slice();\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      WebRTCModule.peerConnectionClose(this._peerConnectionId);\n    }\n  }, {\n    key: \"restartIce\",\n    value: function restartIce() {\n      WebRTCModule.peerConnectionRestartIce(this._peerConnectionId);\n    }\n  }, {\n    key: \"_unregisterEvents\",\n    value: function _unregisterEvents() {\n      this._subscriptions.forEach(function (e) {\n        return e.remove();\n      });\n\n      this._subscriptions = [];\n    }\n  }, {\n    key: \"_registerEvents\",\n    value: function _registerEvents() {\n      var _this5 = this;\n\n      this._subscriptions = [EventEmitter.addListener('peerConnectionOnRenegotiationNeeded', function (ev) {\n        if (ev.id !== _this5._peerConnectionId) {\n          return;\n        }\n\n        _this5.dispatchEvent(new RTCEvent('negotiationneeded'));\n      }), EventEmitter.addListener('peerConnectionIceConnectionChanged', function (ev) {\n        if (ev.id !== _this5._peerConnectionId) {\n          return;\n        }\n\n        _this5.iceConnectionState = ev.iceConnectionState;\n\n        _this5.dispatchEvent(new RTCEvent('iceconnectionstatechange'));\n\n        if (ev.iceConnectionState === 'closed') {\n          _this5._unregisterEvents();\n        }\n      }), EventEmitter.addListener('peerConnectionStateChanged', function (ev) {\n        if (ev.id !== _this5._peerConnectionId) {\n          return;\n        }\n\n        _this5.connectionState = ev.connectionState;\n\n        _this5.dispatchEvent(new RTCEvent('connectionstatechange'));\n\n        if (ev.connectionState === 'closed') {\n          _this5._unregisterEvents();\n        }\n      }), EventEmitter.addListener('peerConnectionSignalingStateChanged', function (ev) {\n        if (ev.id !== _this5._peerConnectionId) {\n          return;\n        }\n\n        _this5.signalingState = ev.signalingState;\n\n        _this5.dispatchEvent(new RTCEvent('signalingstatechange'));\n      }), EventEmitter.addListener('peerConnectionAddedStream', function (ev) {\n        if (ev.id !== _this5._peerConnectionId) {\n          return;\n        }\n\n        var stream = new MediaStream(ev);\n\n        _this5._remoteStreams.push(stream);\n\n        _this5.remoteDescription = new RTCSessionDescription(ev.sdp);\n\n        _this5.dispatchEvent(new MediaStreamEvent('addstream', {\n          stream: stream\n        }));\n      }), EventEmitter.addListener('peerConnectionRemovedStream', function (ev) {\n        if (ev.id !== _this5._peerConnectionId) {\n          return;\n        }\n\n        var stream = _this5._remoteStreams.find(function (s) {\n          return s._reactTag === ev.streamId;\n        });\n\n        if (stream) {\n          var index = _this5._remoteStreams.indexOf(stream);\n\n          if (index !== -1) {\n            _this5._remoteStreams.splice(index, 1);\n          }\n        }\n\n        _this5.remoteDescription = new RTCSessionDescription(ev.sdp);\n\n        _this5.dispatchEvent(new MediaStreamEvent('removestream', {\n          stream: stream\n        }));\n      }), EventEmitter.addListener('mediaStreamTrackMuteChanged', function (ev) {\n        if (ev.peerConnectionId !== _this5._peerConnectionId) {\n          return;\n        }\n\n        var track;\n\n        for (var _iterator = _createForOfIteratorHelperLoose(_this5._remoteStreams), _step; !(_step = _iterator()).done;) {\n          var stream = _step.value;\n\n          var t = stream._tracks.find(function (track) {\n            return track.id === ev.trackId;\n          });\n\n          if (t) {\n            track = t;\n            break;\n          }\n        }\n\n        if (track) {\n          track._muted = ev.muted;\n          var eventName = ev.muted ? 'mute' : 'unmute';\n          track.dispatchEvent(new MediaStreamTrackEvent(eventName, {\n            track: track\n          }));\n        }\n      }), EventEmitter.addListener('peerConnectionGotICECandidate', function (ev) {\n        if (ev.id !== _this5._peerConnectionId) {\n          return;\n        }\n\n        _this5.localDescription = new RTCSessionDescription(ev.sdp);\n        var candidate = new RTCIceCandidate(ev.candidate);\n\n        _this5.dispatchEvent(new RTCIceCandidateEvent('icecandidate', {\n          candidate: candidate\n        }));\n      }), EventEmitter.addListener('peerConnectionIceGatheringChanged', function (ev) {\n        if (ev.id !== _this5._peerConnectionId) {\n          return;\n        }\n\n        _this5.iceGatheringState = ev.iceGatheringState;\n\n        if (_this5.iceGatheringState === 'complete') {\n          _this5.localDescription = new RTCSessionDescription(ev.sdp);\n\n          _this5.dispatchEvent(new RTCIceCandidateEvent('icecandidate', {\n            candidate: null\n          }));\n        }\n\n        _this5.dispatchEvent(new RTCEvent('icegatheringstatechange'));\n      }), EventEmitter.addListener('peerConnectionDidOpenDataChannel', function (ev) {\n        if (ev.id !== _this5._peerConnectionId) {\n          return;\n        }\n\n        var channel = new RTCDataChannel(ev.dataChannel);\n\n        _this5.dispatchEvent(new RTCDataChannelEvent('datachannel', {\n          channel: channel\n        }));\n      })];\n    }\n  }, {\n    key: \"createDataChannel\",\n    value: function createDataChannel(label, dataChannelDict) {\n      if (dataChannelDict && 'id' in dataChannelDict) {\n        var id = dataChannelDict.id;\n\n        if (typeof id !== 'number') {\n          throw new TypeError('DataChannel id must be a number: ' + id);\n        }\n      }\n\n      var channelInfo = WebRTCModule.createDataChannel(this._peerConnectionId, label, dataChannelDict);\n\n      if (channelInfo === null) {\n        throw new TypeError('Failed to create new DataChannel');\n      }\n\n      return new RTCDataChannel(channelInfo);\n    }\n  }]);\n\n  return RTCPeerConnection;\n}(defineCustomEventTarget.apply(void 0, PEER_CONNECTION_EVENTS));\n\nexport { RTCPeerConnection as default };","map":{"version":3,"sources":["RTCPeerConnection.ts"],"names":["WebRTCModule","PEER_CONNECTION_EVENTS","nextPeerConnectionId","defineCustomEventTarget","constructor","addStream","index","stream","removeStream","createOffer","RTCUtil","resolve","reject","createAnswer","options","setConfiguration","setLocalDescription","desc","sessionDescription","newSdp","setRemoteDescription","addIceCandidate","candidate","getStats","data","JSON","getLocalStreams","getRemoteStreams","close","restartIce","_unregisterEvents","e","_registerEvents","ev","s","t","track","eventName","channel","createDataChannel","dataChannelDict","id","channelInfo"],"mappings":"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","sourcesContent":["\nimport { defineCustomEventTarget } from 'event-target-shim';\nimport { NativeModules } from 'react-native';\n\nimport MediaStream from './MediaStream';\nimport MediaStreamEvent from './MediaStreamEvent';\nimport MediaStreamTrackEvent from './MediaStreamTrackEvent';\nimport RTCDataChannel from './RTCDataChannel';\nimport RTCDataChannelEvent from './RTCDataChannelEvent';\nimport RTCSessionDescription from './RTCSessionDescription';\nimport RTCIceCandidate from './RTCIceCandidate';\nimport RTCIceCandidateEvent from './RTCIceCandidateEvent';\nimport RTCEvent from './RTCEvent';\nimport * as RTCUtil from './RTCUtil';\nimport EventEmitter from './EventEmitter';\n\nconst { WebRTCModule } = NativeModules;\n\ntype RTCSignalingState =\n    | 'stable'\n    | 'have-local-offer'\n    | 'have-remote-offer'\n    | 'have-local-pranswer'\n    | 'have-remote-pranswer'\n    | 'closed';\n\ntype RTCIceGatheringState = 'new' | 'gathering' | 'complete';\n\ntype RTCPeerConnectionState = 'new' | 'connecting' | 'connected' | 'disconnected' | 'failed' | 'closed';\n\ntype RTCIceConnectionState = 'new' | 'checking' | 'connected' | 'completed' | 'failed' | 'disconnected' | 'closed';\n\ntype RTCDataChannelInit = {\n    ordered?: boolean,\n    maxPacketLifeTime?: number,\n    maxRetransmits?: number,\n    protocol?: string,\n    negotiated?: boolean,\n    id?: number\n};\n\nconst PEER_CONNECTION_EVENTS = [\n    'connectionstatechange',\n    'icecandidate',\n    'icecandidateerror',\n    'iceconnectionstatechange',\n    'icegatheringstatechange',\n    'negotiationneeded',\n    'signalingstatechange',\n    'datachannel',\n    'addstream',\n    'removestream'\n];\n\nlet nextPeerConnectionId = 0;\n\nexport default class RTCPeerConnection extends defineCustomEventTarget(...PEER_CONNECTION_EVENTS) {\n    localDescription: RTCSessionDescription | null = null;\n    remoteDescription: RTCSessionDescription | null = null;\n\n    signalingState: RTCSignalingState = 'stable';\n    iceGatheringState: RTCIceGatheringState = 'new';\n    connectionState: RTCPeerConnectionState = 'new';\n    iceConnectionState: RTCIceConnectionState = 'new';\n\n    _peerConnectionId: number;\n    _localStreams: Array<MediaStream> = [];\n    _remoteStreams: Array<MediaStream> = [];\n    _subscriptions: Array<any> = [];\n\n    constructor(configuration) {\n        super();\n        this._peerConnectionId = nextPeerConnectionId++;\n        WebRTCModule.peerConnectionInit(configuration, this._peerConnectionId);\n        this._registerEvents();\n    }\n\n    addStream(stream: MediaStream) {\n        const index = this._localStreams.indexOf(stream);\n        if (index !== -1) {\n            return;\n        }\n        WebRTCModule.peerConnectionAddStream(stream._reactTag, this._peerConnectionId);\n        this._localStreams.push(stream);\n    }\n\n    removeStream(stream: MediaStream) {\n        const index = this._localStreams.indexOf(stream);\n        if (index === -1) {\n            return;\n        }\n        this._localStreams.splice(index, 1);\n        WebRTCModule.peerConnectionRemoveStream(stream._reactTag, this._peerConnectionId);\n    }\n\n    createOffer(options) {\n        return new Promise((resolve, reject) => {\n            WebRTCModule.peerConnectionCreateOffer(\n                this._peerConnectionId,\n                RTCUtil.normalizeOfferAnswerOptions(options),\n                (successful, data) => {\n                    if (successful) {\n                        resolve(data);\n                    } else {\n                        reject(data); // TODO: convert to NavigatorUserMediaError\n                    }\n                }\n            );\n        });\n    }\n\n    createAnswer(options = {}) {\n        return new Promise((resolve, reject) => {\n            WebRTCModule.peerConnectionCreateAnswer(\n                this._peerConnectionId,\n                RTCUtil.normalizeOfferAnswerOptions(options),\n                (successful, data) => {\n                    if (successful) {\n                        resolve(data);\n                    } else {\n                        reject(data);\n                    }\n                }\n            );\n        });\n    }\n\n    setConfiguration(configuration) {\n        WebRTCModule.peerConnectionSetConfiguration(configuration, this._peerConnectionId);\n    }\n\n    async setLocalDescription(sessionDescription?: RTCSessionDescription): Promise<void> {\n        const desc = sessionDescription\n            ? sessionDescription.toJSON\n                ? sessionDescription.toJSON()\n                : sessionDescription\n            : null;\n        const newSdp = await WebRTCModule.peerConnectionSetLocalDescription(this._peerConnectionId, desc);\n\n        this.localDescription = new RTCSessionDescription(newSdp);\n    }\n\n    setRemoteDescription(sessionDescription: RTCSessionDescription): Promise<void> {\n        return new Promise((resolve, reject) => {\n            WebRTCModule.peerConnectionSetRemoteDescription(\n                sessionDescription.toJSON ? sessionDescription.toJSON() : sessionDescription,\n                this._peerConnectionId,\n                (successful, data) => {\n                    if (successful) {\n                        this.remoteDescription = new RTCSessionDescription(data);\n                        resolve();\n                    } else {\n                        reject(data);\n                    }\n                }\n            );\n        });\n    }\n\n    async addIceCandidate(candidate): Promise<void> {\n        if (!candidate || !candidate.candidate) {\n            // XXX end-of cantidates is not implemented: https://bugs.chromium.org/p/webrtc/issues/detail?id=9218\n            return;\n        }\n\n        const newSdp = await WebRTCModule.peerConnectionAddICECandidate(\n            this._peerConnectionId,\n            candidate.toJSON ? candidate.toJSON() : candidate\n        );\n\n        this.remoteDescription = new RTCSessionDescription(newSdp);\n    }\n\n    getStats() {\n        return WebRTCModule.peerConnectionGetStats(this._peerConnectionId).then(data => {\n            /* On both Android and iOS it is faster to construct a single\n            JSON string representing the Map of StatsReports and have it\n            pass through the React Native bridge rather than the Map of\n            StatsReports. While the implementations do try to be faster in\n            general, the stress is on being faster to pass through the React\n            Native bridge which is a bottleneck that tends to be visible in\n            the UI when there is congestion involving UI-related passing.\n\n            TODO Implement the logic for filtering the stats based on \n            the sender/receiver\n            */\n            return new Map(JSON.parse(data));\n        });\n    }\n\n    getLocalStreams() {\n        return this._localStreams.slice();\n    }\n\n    getRemoteStreams() {\n        return this._remoteStreams.slice();\n    }\n\n    close() {\n        WebRTCModule.peerConnectionClose(this._peerConnectionId);\n    }\n\n    restartIce() {\n        WebRTCModule.peerConnectionRestartIce(this._peerConnectionId);\n    }\n\n    _unregisterEvents(): void {\n        this._subscriptions.forEach(e => e.remove());\n        this._subscriptions = [];\n    }\n\n    _registerEvents(): void {\n        this._subscriptions = [\n            EventEmitter.addListener('peerConnectionOnRenegotiationNeeded', ev => {\n                if (ev.id !== this._peerConnectionId) {\n                    return;\n                }\n                // @ts-ignore\n                this.dispatchEvent(new RTCEvent('negotiationneeded'));\n            }),\n            EventEmitter.addListener('peerConnectionIceConnectionChanged', ev => {\n                if (ev.id !== this._peerConnectionId) {\n                    return;\n                }\n                this.iceConnectionState = ev.iceConnectionState;\n                // @ts-ignore\n                this.dispatchEvent(new RTCEvent('iceconnectionstatechange'));\n                if (ev.iceConnectionState === 'closed') {\n                    // This PeerConnection is done, clean up event handlers.\n                    this._unregisterEvents();\n                }\n            }),\n            EventEmitter.addListener('peerConnectionStateChanged', ev => {\n                if (ev.id !== this._peerConnectionId) {\n                    return;\n                }\n                this.connectionState = ev.connectionState;\n                // @ts-ignore\n                this.dispatchEvent(new RTCEvent('connectionstatechange'));\n                if (ev.connectionState === 'closed') {\n                    // This PeerConnection is done, clean up event handlers.\n                    this._unregisterEvents();\n                }\n            }),\n            EventEmitter.addListener('peerConnectionSignalingStateChanged', ev => {\n                if (ev.id !== this._peerConnectionId) {\n                    return;\n                }\n                this.signalingState = ev.signalingState;\n                // @ts-ignore\n                this.dispatchEvent(new RTCEvent('signalingstatechange'));\n            }),\n            EventEmitter.addListener('peerConnectionAddedStream', ev => {\n                if (ev.id !== this._peerConnectionId) {\n                    return;\n                }\n                const stream = new MediaStream(ev);\n                this._remoteStreams.push(stream);\n                this.remoteDescription = new RTCSessionDescription(ev.sdp);\n                // @ts-ignore\n                this.dispatchEvent(new MediaStreamEvent('addstream', { stream }));\n            }),\n            EventEmitter.addListener('peerConnectionRemovedStream', ev => {\n                if (ev.id !== this._peerConnectionId) {\n                    return;\n                }\n                const stream = this._remoteStreams.find(s => s._reactTag === ev.streamId);\n                if (stream) {\n                    const index = this._remoteStreams.indexOf(stream);\n                    if (index !== -1) {\n                        this._remoteStreams.splice(index, 1);\n                    }\n                }\n                this.remoteDescription = new RTCSessionDescription(ev.sdp);\n                // @ts-ignore\n                this.dispatchEvent(new MediaStreamEvent('removestream', { stream }));\n            }),\n            EventEmitter.addListener('mediaStreamTrackMuteChanged', ev => {\n                if (ev.peerConnectionId !== this._peerConnectionId) {\n                    return;\n                }\n                let track;\n                for (const stream of this._remoteStreams) {\n                    const t = stream._tracks.find(track => track.id === ev.trackId);\n                    if (t) {\n                        track = t;\n                        break;\n                    }\n                }\n                if (track) {\n                    track._muted = ev.muted;\n                    const eventName = ev.muted ? 'mute' : 'unmute';\n                    track.dispatchEvent(new MediaStreamTrackEvent(eventName, { track }));\n                }\n            }),\n            EventEmitter.addListener('peerConnectionGotICECandidate', ev => {\n                if (ev.id !== this._peerConnectionId) {\n                    return;\n                }\n                this.localDescription = new RTCSessionDescription(ev.sdp);\n                const candidate = new RTCIceCandidate(ev.candidate);\n                // @ts-ignore\n                this.dispatchEvent(new RTCIceCandidateEvent('icecandidate', { candidate }));\n            }),\n            EventEmitter.addListener('peerConnectionIceGatheringChanged', ev => {\n                if (ev.id !== this._peerConnectionId) {\n                    return;\n                }\n                this.iceGatheringState = ev.iceGatheringState;\n\n                if (this.iceGatheringState === 'complete') {\n                    this.localDescription = new RTCSessionDescription(ev.sdp);\n                    // @ts-ignore\n                    this.dispatchEvent(new RTCIceCandidateEvent('icecandidate', { candidate: null }));\n                }\n\n                // @ts-ignore\n                this.dispatchEvent(new RTCEvent('icegatheringstatechange'));\n            }),\n            EventEmitter.addListener('peerConnectionDidOpenDataChannel', ev => {\n                if (ev.id !== this._peerConnectionId) {\n                    return;\n                }\n                const channel = new RTCDataChannel(ev.dataChannel);\n                // @ts-ignore\n                this.dispatchEvent(new RTCDataChannelEvent('datachannel', { channel }));\n            })\n        ];\n    }\n\n    /**\n     * Creates a new RTCDataChannel object with the given label. The\n     * RTCDataChannelInit dictionary can be used to configure properties of the\n     * underlying channel such as data reliability.\n     *\n     * @param {string} label - the value with which the label attribute of the new\n     * instance is to be initialized\n     * @param {RTCDataChannelInit} dataChannelDict - an optional dictionary of\n     * values with which to initialize corresponding attributes of the new\n     * instance such as id\n     */\n    createDataChannel(label: string, dataChannelDict?: RTCDataChannelInit) {\n        if (dataChannelDict && 'id' in dataChannelDict) {\n            const id = dataChannelDict.id;\n            if (typeof id !== 'number') {\n                throw new TypeError('DataChannel id must be a number: ' + id);\n            }\n        }\n\n        const channelInfo = WebRTCModule.createDataChannel(this._peerConnectionId, label, dataChannelDict);\n\n        if (channelInfo === null) {\n            throw new TypeError('Failed to create new DataChannel');\n        }\n\n        return new RTCDataChannel(channelInfo);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}
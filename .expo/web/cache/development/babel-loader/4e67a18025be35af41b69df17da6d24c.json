{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\n\nvar _set = require(\"@babel/runtime/helpers/set\");\n\nvar _get = require(\"@babel/runtime/helpers/get\");\n\nvar _assertThisInitialized = require(\"@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nvar _wrapNativeSuper = require(\"@babel/runtime/helpers/wrapNativeSuper\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction assertType(condition, message) {\n  if (!condition) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    throw new TypeError(format(message, args));\n  }\n}\n\nfunction format(message, args) {\n  var i = 0;\n  return message.replace(/%[os]/g, function () {\n    return anyToString(args[i++]);\n  });\n}\n\nfunction anyToString(x) {\n  if (typeof x !== \"object\" || x === null) {\n    return String(x);\n  }\n\n  return Object.prototype.toString.call(x);\n}\n\nvar currentErrorHandler;\n\nfunction setErrorHandler(value) {\n  assertType(typeof value === \"function\" || value === undefined, \"The error handler must be a function or undefined, but got %o.\", value);\n  currentErrorHandler = value;\n}\n\nfunction reportError(maybeError) {\n  try {\n    var error = maybeError instanceof Error ? maybeError : new Error(anyToString(maybeError));\n\n    if (currentErrorHandler) {\n      currentErrorHandler(error);\n      return;\n    }\n\n    if (typeof dispatchEvent === \"function\" && typeof ErrorEvent === \"function\") {\n      dispatchEvent(new ErrorEvent(\"error\", {\n        error: error,\n        message: error.message\n      }));\n    } else if (typeof process !== \"undefined\" && typeof process.emit === \"function\") {\n      process.emit(\"uncaughtException\", error);\n      return;\n    }\n\n    console.error(error);\n  } catch (_a) {}\n}\n\nvar Global = typeof window !== \"undefined\" ? window : typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : typeof globalThis !== \"undefined\" ? globalThis : undefined;\nvar currentWarnHandler;\n\nfunction setWarningHandler(value) {\n  assertType(typeof value === \"function\" || value === undefined, \"The warning handler must be a function or undefined, but got %o.\", value);\n  currentWarnHandler = value;\n}\n\nvar Warning = function () {\n  function Warning(code, message) {\n    _classCallCheck(this, Warning);\n\n    this.code = code;\n    this.message = message;\n  }\n\n  _createClass(Warning, [{\n    key: \"warn\",\n    value: function warn() {\n      var _a;\n\n      try {\n        var _console;\n\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        if (currentWarnHandler) {\n          currentWarnHandler(_objectSpread(_objectSpread({}, this), {}, {\n            args: args\n          }));\n          return;\n        }\n\n        var stack = ((_a = new Error().stack) !== null && _a !== void 0 ? _a : \"\").replace(/^(?:(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+?\\n){2}/g, \"\\n\");\n\n        (_console = console).warn.apply(_console, [this.message].concat(args, [stack]));\n      } catch (_b) {}\n    }\n  }]);\n\n  return Warning;\n}();\n\nvar InitEventWasCalledWhileDispatching = new Warning(\"W01\", \"Unable to initialize event under dispatching.\");\nvar FalsyWasAssignedToCancelBubble = new Warning(\"W02\", \"Assigning any falsy value to 'cancelBubble' property has no effect.\");\nvar TruthyWasAssignedToReturnValue = new Warning(\"W03\", \"Assigning any truthy value to 'returnValue' property has no effect.\");\nvar NonCancelableEventWasCanceled = new Warning(\"W04\", \"Unable to preventDefault on non-cancelable events.\");\nvar CanceledInPassiveListener = new Warning(\"W05\", \"Unable to preventDefault inside passive event listener invocation.\");\nvar EventListenerWasDuplicated = new Warning(\"W06\", \"An event listener wasn't added because it has been added already: %o, %o\");\nvar OptionWasIgnored = new Warning(\"W07\", \"The %o option value was abandoned because the event listener wasn't added as duplicated.\");\nvar InvalidEventListener = new Warning(\"W08\", \"The 'callback' argument must be a function or an object that has 'handleEvent' method: %o\");\nvar InvalidAttributeHandler = new Warning(\"W09\", \"Event attribute handler must be a function: %o\");\n\nvar Event = function () {\n  function Event(type, eventInitDict) {\n    _classCallCheck(this, Event);\n\n    Object.defineProperty(this, \"isTrusted\", {\n      value: false,\n      enumerable: true\n    });\n    var opts = eventInitDict !== null && eventInitDict !== void 0 ? eventInitDict : {};\n    internalDataMap.set(this, {\n      type: String(type),\n      bubbles: Boolean(opts.bubbles),\n      cancelable: Boolean(opts.cancelable),\n      composed: Boolean(opts.composed),\n      target: null,\n      currentTarget: null,\n      stopPropagationFlag: false,\n      stopImmediatePropagationFlag: false,\n      canceledFlag: false,\n      inPassiveListenerFlag: false,\n      dispatchFlag: false,\n      timeStamp: Date.now()\n    });\n  }\n\n  _createClass(Event, [{\n    key: \"type\",\n    get: function get() {\n      return $(this).type;\n    }\n  }, {\n    key: \"target\",\n    get: function get() {\n      return $(this).target;\n    }\n  }, {\n    key: \"srcElement\",\n    get: function get() {\n      return $(this).target;\n    }\n  }, {\n    key: \"currentTarget\",\n    get: function get() {\n      return $(this).currentTarget;\n    }\n  }, {\n    key: \"composedPath\",\n    value: function composedPath() {\n      var currentTarget = $(this).currentTarget;\n\n      if (currentTarget) {\n        return [currentTarget];\n      }\n\n      return [];\n    }\n  }, {\n    key: \"NONE\",\n    get: function get() {\n      return NONE;\n    }\n  }, {\n    key: \"CAPTURING_PHASE\",\n    get: function get() {\n      return CAPTURING_PHASE;\n    }\n  }, {\n    key: \"AT_TARGET\",\n    get: function get() {\n      return AT_TARGET;\n    }\n  }, {\n    key: \"BUBBLING_PHASE\",\n    get: function get() {\n      return BUBBLING_PHASE;\n    }\n  }, {\n    key: \"eventPhase\",\n    get: function get() {\n      return $(this).dispatchFlag ? 2 : 0;\n    }\n  }, {\n    key: \"stopPropagation\",\n    value: function stopPropagation() {\n      $(this).stopPropagationFlag = true;\n    }\n  }, {\n    key: \"cancelBubble\",\n    get: function get() {\n      return $(this).stopPropagationFlag;\n    },\n    set: function set(value) {\n      if (value) {\n        $(this).stopPropagationFlag = true;\n      } else {\n        FalsyWasAssignedToCancelBubble.warn();\n      }\n    }\n  }, {\n    key: \"stopImmediatePropagation\",\n    value: function stopImmediatePropagation() {\n      var data = $(this);\n      data.stopPropagationFlag = data.stopImmediatePropagationFlag = true;\n    }\n  }, {\n    key: \"bubbles\",\n    get: function get() {\n      return $(this).bubbles;\n    }\n  }, {\n    key: \"cancelable\",\n    get: function get() {\n      return $(this).cancelable;\n    }\n  }, {\n    key: \"returnValue\",\n    get: function get() {\n      return !$(this).canceledFlag;\n    },\n    set: function set(value) {\n      if (!value) {\n        setCancelFlag($(this));\n      } else {\n        TruthyWasAssignedToReturnValue.warn();\n      }\n    }\n  }, {\n    key: \"preventDefault\",\n    value: function preventDefault() {\n      setCancelFlag($(this));\n    }\n  }, {\n    key: \"defaultPrevented\",\n    get: function get() {\n      return $(this).canceledFlag;\n    }\n  }, {\n    key: \"composed\",\n    get: function get() {\n      return $(this).composed;\n    }\n  }, {\n    key: \"isTrusted\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"timeStamp\",\n    get: function get() {\n      return $(this).timeStamp;\n    }\n  }, {\n    key: \"initEvent\",\n    value: function initEvent(type) {\n      var bubbles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var cancelable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var data = $(this);\n\n      if (data.dispatchFlag) {\n        InitEventWasCalledWhileDispatching.warn();\n        return;\n      }\n\n      internalDataMap.set(this, _objectSpread(_objectSpread({}, data), {}, {\n        type: String(type),\n        bubbles: Boolean(bubbles),\n        cancelable: Boolean(cancelable),\n        target: null,\n        currentTarget: null,\n        stopPropagationFlag: false,\n        stopImmediatePropagationFlag: false,\n        canceledFlag: false\n      }));\n    }\n  }], [{\n    key: \"NONE\",\n    get: function get() {\n      return NONE;\n    }\n  }, {\n    key: \"CAPTURING_PHASE\",\n    get: function get() {\n      return CAPTURING_PHASE;\n    }\n  }, {\n    key: \"AT_TARGET\",\n    get: function get() {\n      return AT_TARGET;\n    }\n  }, {\n    key: \"BUBBLING_PHASE\",\n    get: function get() {\n      return BUBBLING_PHASE;\n    }\n  }]);\n\n  return Event;\n}();\n\nvar NONE = 0;\nvar CAPTURING_PHASE = 1;\nvar AT_TARGET = 2;\nvar BUBBLING_PHASE = 3;\nvar internalDataMap = new WeakMap();\n\nfunction $(event) {\n  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"this\";\n  var retv = internalDataMap.get(event);\n  assertType(retv != null, \"'%s' must be an object that Event constructor created, but got another one: %o\", name, event);\n  return retv;\n}\n\nfunction setCancelFlag(data) {\n  if (data.inPassiveListenerFlag) {\n    CanceledInPassiveListener.warn();\n    return;\n  }\n\n  if (!data.cancelable) {\n    NonCancelableEventWasCanceled.warn();\n    return;\n  }\n\n  data.canceledFlag = true;\n}\n\nObject.defineProperty(Event, \"NONE\", {\n  enumerable: true\n});\nObject.defineProperty(Event, \"CAPTURING_PHASE\", {\n  enumerable: true\n});\nObject.defineProperty(Event, \"AT_TARGET\", {\n  enumerable: true\n});\nObject.defineProperty(Event, \"BUBBLING_PHASE\", {\n  enumerable: true\n});\nvar keys = Object.getOwnPropertyNames(Event.prototype);\n\nfor (var i = 0; i < keys.length; ++i) {\n  if (keys[i] === \"constructor\") {\n    continue;\n  }\n\n  Object.defineProperty(Event.prototype, keys[i], {\n    enumerable: true\n  });\n}\n\nif (typeof Global !== \"undefined\" && typeof Global.Event !== \"undefined\") {\n  Object.setPrototypeOf(Event.prototype, Global.Event.prototype);\n}\n\nfunction createInvalidStateError(message) {\n  if (Global.DOMException) {\n    return new Global.DOMException(message, \"InvalidStateError\");\n  }\n\n  if (DOMException == null) {\n    DOMException = function (_Error) {\n      _inherits(DOMException, _Error);\n\n      var _super = _createSuper(DOMException);\n\n      function DOMException(msg) {\n        var _this;\n\n        _classCallCheck(this, DOMException);\n\n        _this = _super.call(this, msg);\n\n        if (Error.captureStackTrace) {\n          Error.captureStackTrace(_assertThisInitialized(_this), DOMException);\n        }\n\n        return _this;\n      }\n\n      _createClass(DOMException, [{\n        key: \"code\",\n        get: function get() {\n          return 11;\n        }\n      }, {\n        key: \"name\",\n        get: function get() {\n          return \"InvalidStateError\";\n        }\n      }]);\n\n      return DOMException;\n    }(_wrapNativeSuper(Error));\n\n    Object.defineProperties(DOMException.prototype, {\n      code: {\n        enumerable: true\n      },\n      name: {\n        enumerable: true\n      }\n    });\n    defineErrorCodeProperties(DOMException);\n    defineErrorCodeProperties(DOMException.prototype);\n  }\n\n  return new DOMException(message);\n}\n\nvar DOMException;\nvar ErrorCodeMap = {\n  INDEX_SIZE_ERR: 1,\n  DOMSTRING_SIZE_ERR: 2,\n  HIERARCHY_REQUEST_ERR: 3,\n  WRONG_DOCUMENT_ERR: 4,\n  INVALID_CHARACTER_ERR: 5,\n  NO_DATA_ALLOWED_ERR: 6,\n  NO_MODIFICATION_ALLOWED_ERR: 7,\n  NOT_FOUND_ERR: 8,\n  NOT_SUPPORTED_ERR: 9,\n  INUSE_ATTRIBUTE_ERR: 10,\n  INVALID_STATE_ERR: 11,\n  SYNTAX_ERR: 12,\n  INVALID_MODIFICATION_ERR: 13,\n  NAMESPACE_ERR: 14,\n  INVALID_ACCESS_ERR: 15,\n  VALIDATION_ERR: 16,\n  TYPE_MISMATCH_ERR: 17,\n  SECURITY_ERR: 18,\n  NETWORK_ERR: 19,\n  ABORT_ERR: 20,\n  URL_MISMATCH_ERR: 21,\n  QUOTA_EXCEEDED_ERR: 22,\n  TIMEOUT_ERR: 23,\n  INVALID_NODE_TYPE_ERR: 24,\n  DATA_CLONE_ERR: 25\n};\n\nfunction defineErrorCodeProperties(obj) {\n  var keys = Object.keys(ErrorCodeMap);\n\n  var _loop = function _loop(_i) {\n    var key = keys[_i];\n    var value = ErrorCodeMap[key];\n    Object.defineProperty(obj, key, {\n      get: function get() {\n        return value;\n      },\n      configurable: true,\n      enumerable: true\n    });\n  };\n\n  for (var _i = 0; _i < keys.length; ++_i) {\n    _loop(_i);\n  }\n}\n\nvar EventWrapper = function (_Event) {\n  _inherits(EventWrapper, _Event);\n\n  var _super2 = _createSuper(EventWrapper);\n\n  function EventWrapper(event) {\n    var _thisSuper, _thisSuper2, _this2;\n\n    _classCallCheck(this, EventWrapper);\n\n    _this2 = _super2.call(this, event.type, {\n      bubbles: event.bubbles,\n      cancelable: event.cancelable,\n      composed: event.composed\n    });\n\n    if (event.cancelBubble) {\n      _get((_thisSuper = _assertThisInitialized(_this2), _getPrototypeOf(EventWrapper.prototype)), \"stopPropagation\", _thisSuper).call(_thisSuper);\n    }\n\n    if (event.defaultPrevented) {\n      _get((_thisSuper2 = _assertThisInitialized(_this2), _getPrototypeOf(EventWrapper.prototype)), \"preventDefault\", _thisSuper2).call(_thisSuper2);\n    }\n\n    internalDataMap$1.set(_assertThisInitialized(_this2), {\n      original: event\n    });\n    var keys = Object.keys(event);\n\n    for (var _i2 = 0; _i2 < keys.length; ++_i2) {\n      var key = keys[_i2];\n\n      if (!(key in _assertThisInitialized(_this2))) {\n        Object.defineProperty(_assertThisInitialized(_this2), key, defineRedirectDescriptor(event, key));\n      }\n    }\n\n    return _this2;\n  }\n\n  _createClass(EventWrapper, [{\n    key: \"stopPropagation\",\n    value: function stopPropagation() {\n      _get(_getPrototypeOf(EventWrapper.prototype), \"stopPropagation\", this).call(this);\n\n      var _$$ = $$1(this),\n          original = _$$.original;\n\n      if (\"stopPropagation\" in original) {\n        original.stopPropagation();\n      }\n    }\n  }, {\n    key: \"cancelBubble\",\n    get: function get() {\n      return _get(_getPrototypeOf(EventWrapper.prototype), \"cancelBubble\", this);\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(EventWrapper.prototype), \"cancelBubble\", value, this, true);\n\n      var _$$2 = $$1(this),\n          original = _$$2.original;\n\n      if (\"cancelBubble\" in original) {\n        original.cancelBubble = value;\n      }\n    }\n  }, {\n    key: \"stopImmediatePropagation\",\n    value: function stopImmediatePropagation() {\n      _get(_getPrototypeOf(EventWrapper.prototype), \"stopImmediatePropagation\", this).call(this);\n\n      var _$$3 = $$1(this),\n          original = _$$3.original;\n\n      if (\"stopImmediatePropagation\" in original) {\n        original.stopImmediatePropagation();\n      }\n    }\n  }, {\n    key: \"returnValue\",\n    get: function get() {\n      return _get(_getPrototypeOf(EventWrapper.prototype), \"returnValue\", this);\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(EventWrapper.prototype), \"returnValue\", value, this, true);\n\n      var _$$4 = $$1(this),\n          original = _$$4.original;\n\n      if (\"returnValue\" in original) {\n        original.returnValue = value;\n      }\n    }\n  }, {\n    key: \"preventDefault\",\n    value: function preventDefault() {\n      _get(_getPrototypeOf(EventWrapper.prototype), \"preventDefault\", this).call(this);\n\n      var _$$5 = $$1(this),\n          original = _$$5.original;\n\n      if (\"preventDefault\" in original) {\n        original.preventDefault();\n      }\n    }\n  }, {\n    key: \"timeStamp\",\n    get: function get() {\n      var _$$6 = $$1(this),\n          original = _$$6.original;\n\n      if (\"timeStamp\" in original) {\n        return original.timeStamp;\n      }\n\n      return _get(_getPrototypeOf(EventWrapper.prototype), \"timeStamp\", this);\n    }\n  }], [{\n    key: \"wrap\",\n    value: function wrap(event) {\n      return new (getWrapperClassOf(event))(event);\n    }\n  }]);\n\n  return EventWrapper;\n}(Event);\n\nvar internalDataMap$1 = new WeakMap();\n\nfunction $$1(event) {\n  var retv = internalDataMap$1.get(event);\n  assertType(retv != null, \"'this' is expected an Event object, but got\", event);\n  return retv;\n}\n\nvar wrapperClassCache = new WeakMap();\nwrapperClassCache.set(Object.prototype, EventWrapper);\n\nif (typeof Global !== \"undefined\" && typeof Global.Event !== \"undefined\") {\n  wrapperClassCache.set(Global.Event.prototype, EventWrapper);\n}\n\nfunction getWrapperClassOf(originalEvent) {\n  var prototype = Object.getPrototypeOf(originalEvent);\n\n  if (prototype == null) {\n    return EventWrapper;\n  }\n\n  var wrapper = wrapperClassCache.get(prototype);\n\n  if (wrapper == null) {\n    wrapper = defineWrapper(getWrapperClassOf(prototype), prototype);\n    wrapperClassCache.set(prototype, wrapper);\n  }\n\n  return wrapper;\n}\n\nfunction defineWrapper(BaseEventWrapper, originalPrototype) {\n  var CustomEventWrapper = function (_BaseEventWrapper) {\n    _inherits(CustomEventWrapper, _BaseEventWrapper);\n\n    var _super3 = _createSuper(CustomEventWrapper);\n\n    function CustomEventWrapper() {\n      _classCallCheck(this, CustomEventWrapper);\n\n      return _super3.apply(this, arguments);\n    }\n\n    return _createClass(CustomEventWrapper);\n  }(BaseEventWrapper);\n\n  var keys = Object.keys(originalPrototype);\n\n  for (var _i3 = 0; _i3 < keys.length; ++_i3) {\n    Object.defineProperty(CustomEventWrapper.prototype, keys[_i3], defineRedirectDescriptor(originalPrototype, keys[_i3]));\n  }\n\n  return CustomEventWrapper;\n}\n\nfunction defineRedirectDescriptor(obj, key) {\n  var d = Object.getOwnPropertyDescriptor(obj, key);\n  return {\n    get: function get() {\n      var original = $$1(this).original;\n      var value = original[key];\n\n      if (typeof value === \"function\") {\n        return value.bind(original);\n      }\n\n      return value;\n    },\n    set: function set(value) {\n      var original = $$1(this).original;\n      original[key] = value;\n    },\n    configurable: d.configurable,\n    enumerable: d.enumerable\n  };\n}\n\nfunction createListener(callback, capture, passive, once, signal, signalListener) {\n  return {\n    callback: callback,\n    flags: (capture ? 1 : 0) | (passive ? 2 : 0) | (once ? 4 : 0),\n    signal: signal,\n    signalListener: signalListener\n  };\n}\n\nfunction setRemoved(listener) {\n  listener.flags |= 8;\n}\n\nfunction isCapture(listener) {\n  return (listener.flags & 1) === 1;\n}\n\nfunction isPassive(listener) {\n  return (listener.flags & 2) === 2;\n}\n\nfunction isOnce(listener) {\n  return (listener.flags & 4) === 4;\n}\n\nfunction isRemoved(listener) {\n  return (listener.flags & 8) === 8;\n}\n\nfunction invokeCallback(_ref, target, event) {\n  var callback = _ref.callback;\n\n  try {\n    if (typeof callback === \"function\") {\n      callback.call(target, event);\n    } else if (typeof callback.handleEvent === \"function\") {\n      callback.handleEvent(event);\n    }\n  } catch (thrownError) {\n    reportError(thrownError);\n  }\n}\n\nfunction findIndexOfListener(_ref2, callback, capture) {\n  var listeners = _ref2.listeners;\n\n  for (var _i4 = 0; _i4 < listeners.length; ++_i4) {\n    if (listeners[_i4].callback === callback && isCapture(listeners[_i4]) === capture) {\n      return _i4;\n    }\n  }\n\n  return -1;\n}\n\nfunction addListener(list, callback, capture, passive, once, signal) {\n  var signalListener;\n\n  if (signal) {\n    signalListener = removeListener.bind(null, list, callback, capture);\n    signal.addEventListener(\"abort\", signalListener);\n  }\n\n  var listener = createListener(callback, capture, passive, once, signal, signalListener);\n\n  if (list.cow) {\n    list.cow = false;\n    list.listeners = [].concat(_toConsumableArray(list.listeners), [listener]);\n  } else {\n    list.listeners.push(listener);\n  }\n\n  return listener;\n}\n\nfunction removeListener(list, callback, capture) {\n  var index = findIndexOfListener(list, callback, capture);\n\n  if (index !== -1) {\n    return removeListenerAt(list, index);\n  }\n\n  return false;\n}\n\nfunction removeListenerAt(list, index) {\n  var disableCow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var listener = list.listeners[index];\n  setRemoved(listener);\n\n  if (listener.signal) {\n    listener.signal.removeEventListener(\"abort\", listener.signalListener);\n  }\n\n  if (list.cow && !disableCow) {\n    list.cow = false;\n    list.listeners = list.listeners.filter(function (_, i) {\n      return i !== index;\n    });\n    return false;\n  }\n\n  list.listeners.splice(index, 1);\n  return true;\n}\n\nfunction createListenerListMap() {\n  return Object.create(null);\n}\n\nfunction ensureListenerList(listenerMap, type) {\n  var _a;\n\n  return (_a = listenerMap[type]) !== null && _a !== void 0 ? _a : listenerMap[type] = {\n    attrCallback: undefined,\n    attrListener: undefined,\n    cow: false,\n    listeners: []\n  };\n}\n\nvar EventTarget = function () {\n  function EventTarget() {\n    _classCallCheck(this, EventTarget);\n\n    internalDataMap$2.set(this, createListenerListMap());\n  }\n\n  _createClass(EventTarget, [{\n    key: \"addEventListener\",\n    value: function addEventListener(type0, callback0, options0) {\n      var listenerMap = $$2(this);\n\n      var _normalizeAddOptions = normalizeAddOptions(type0, callback0, options0),\n          callback = _normalizeAddOptions.callback,\n          capture = _normalizeAddOptions.capture,\n          once = _normalizeAddOptions.once,\n          passive = _normalizeAddOptions.passive,\n          signal = _normalizeAddOptions.signal,\n          type = _normalizeAddOptions.type;\n\n      if (callback == null || (signal === null || signal === void 0 ? void 0 : signal.aborted)) {\n        return;\n      }\n\n      var list = ensureListenerList(listenerMap, type);\n      var i = findIndexOfListener(list, callback, capture);\n\n      if (i !== -1) {\n        warnDuplicate(list.listeners[i], passive, once, signal);\n        return;\n      }\n\n      addListener(list, callback, capture, passive, once, signal);\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(type0, callback0, options0) {\n      var listenerMap = $$2(this);\n\n      var _normalizeOptions = normalizeOptions(type0, callback0, options0),\n          callback = _normalizeOptions.callback,\n          capture = _normalizeOptions.capture,\n          type = _normalizeOptions.type;\n\n      var list = listenerMap[type];\n\n      if (callback != null && list) {\n        removeListener(list, callback, capture);\n      }\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(e) {\n      var list = $$2(this)[String(e.type)];\n\n      if (list == null) {\n        return true;\n      }\n\n      var event = e instanceof Event ? e : EventWrapper.wrap(e);\n      var eventData = $(event, \"event\");\n\n      if (eventData.dispatchFlag) {\n        throw createInvalidStateError(\"This event has been in dispatching.\");\n      }\n\n      eventData.dispatchFlag = true;\n      eventData.target = eventData.currentTarget = this;\n\n      if (!eventData.stopPropagationFlag) {\n        var cow = list.cow,\n            listeners = list.listeners;\n        list.cow = true;\n\n        for (var _i5 = 0; _i5 < listeners.length; ++_i5) {\n          var listener = listeners[_i5];\n\n          if (isRemoved(listener)) {\n            continue;\n          }\n\n          if (isOnce(listener) && removeListenerAt(list, _i5, !cow)) {\n            _i5 -= 1;\n          }\n\n          eventData.inPassiveListenerFlag = isPassive(listener);\n          invokeCallback(listener, this, event);\n          eventData.inPassiveListenerFlag = false;\n\n          if (eventData.stopImmediatePropagationFlag) {\n            break;\n          }\n        }\n\n        if (!cow) {\n          list.cow = false;\n        }\n      }\n\n      eventData.target = null;\n      eventData.currentTarget = null;\n      eventData.stopImmediatePropagationFlag = false;\n      eventData.stopPropagationFlag = false;\n      eventData.dispatchFlag = false;\n      return !eventData.canceledFlag;\n    }\n  }]);\n\n  return EventTarget;\n}();\n\nvar internalDataMap$2 = new WeakMap();\n\nfunction $$2(target) {\n  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"this\";\n  var retv = internalDataMap$2.get(target);\n  assertType(retv != null, \"'%s' must be an object that EventTarget constructor created, but got another one: %o\", name, target);\n  return retv;\n}\n\nfunction normalizeAddOptions(type, callback, options) {\n  var _a;\n\n  assertCallback(callback);\n\n  if (typeof options === \"object\" && options !== null) {\n    return {\n      type: String(type),\n      callback: callback !== null && callback !== void 0 ? callback : undefined,\n      capture: Boolean(options.capture),\n      passive: Boolean(options.passive),\n      once: Boolean(options.once),\n      signal: (_a = options.signal) !== null && _a !== void 0 ? _a : undefined\n    };\n  }\n\n  return {\n    type: String(type),\n    callback: callback !== null && callback !== void 0 ? callback : undefined,\n    capture: Boolean(options),\n    passive: false,\n    once: false,\n    signal: undefined\n  };\n}\n\nfunction normalizeOptions(type, callback, options) {\n  assertCallback(callback);\n\n  if (typeof options === \"object\" && options !== null) {\n    return {\n      type: String(type),\n      callback: callback !== null && callback !== void 0 ? callback : undefined,\n      capture: Boolean(options.capture)\n    };\n  }\n\n  return {\n    type: String(type),\n    callback: callback !== null && callback !== void 0 ? callback : undefined,\n    capture: Boolean(options)\n  };\n}\n\nfunction assertCallback(callback) {\n  if (typeof callback === \"function\" || typeof callback === \"object\" && callback !== null && typeof callback.handleEvent === \"function\") {\n    return;\n  }\n\n  if (callback == null || typeof callback === \"object\") {\n    InvalidEventListener.warn(callback);\n    return;\n  }\n\n  throw new TypeError(format(InvalidEventListener.message, [callback]));\n}\n\nfunction warnDuplicate(listener, passive, once, signal) {\n  EventListenerWasDuplicated.warn(isCapture(listener) ? \"capture\" : \"bubble\", listener.callback);\n\n  if (isPassive(listener) !== passive) {\n    OptionWasIgnored.warn(\"passive\");\n  }\n\n  if (isOnce(listener) !== once) {\n    OptionWasIgnored.warn(\"once\");\n  }\n\n  if (listener.signal !== signal) {\n    OptionWasIgnored.warn(\"signal\");\n  }\n}\n\nvar keys$1 = Object.getOwnPropertyNames(EventTarget.prototype);\n\nfor (var _i6 = 0; _i6 < keys$1.length; ++_i6) {\n  if (keys$1[_i6] === \"constructor\") {\n    continue;\n  }\n\n  Object.defineProperty(EventTarget.prototype, keys$1[_i6], {\n    enumerable: true\n  });\n}\n\nif (typeof Global !== \"undefined\" && typeof Global.EventTarget !== \"undefined\") {\n  Object.setPrototypeOf(EventTarget.prototype, Global.EventTarget.prototype);\n}\n\nfunction getEventAttributeValue(target, type) {\n  var _a, _b;\n\n  var listMap = $$2(target, \"target\");\n  return (_b = (_a = listMap[type]) === null || _a === void 0 ? void 0 : _a.attrCallback) !== null && _b !== void 0 ? _b : null;\n}\n\nfunction setEventAttributeValue(target, type, callback) {\n  if (callback != null && typeof callback !== \"function\") {\n    InvalidAttributeHandler.warn(callback);\n  }\n\n  if (typeof callback === \"function\" || typeof callback === \"object\" && callback !== null) {\n    upsertEventAttributeListener(target, type, callback);\n  } else {\n    removeEventAttributeListener(target, type);\n  }\n}\n\nfunction upsertEventAttributeListener(target, type, callback) {\n  var list = ensureListenerList($$2(target, \"target\"), String(type));\n  list.attrCallback = callback;\n\n  if (list.attrListener == null) {\n    list.attrListener = addListener(list, defineEventAttributeCallback(list), false, false, false, undefined);\n  }\n}\n\nfunction removeEventAttributeListener(target, type) {\n  var listMap = $$2(target, \"target\");\n  var list = listMap[String(type)];\n\n  if (list && list.attrListener) {\n    removeListener(list, list.attrListener.callback, false);\n    list.attrCallback = list.attrListener = undefined;\n  }\n}\n\nfunction defineEventAttributeCallback(list) {\n  return function (event) {\n    var callback = list.attrCallback;\n\n    if (typeof callback === \"function\") {\n      callback.call(this, event);\n    }\n  };\n}\n\nfunction defineCustomEventTarget() {\n  var CustomEventTarget = function (_EventTarget) {\n    _inherits(CustomEventTarget, _EventTarget);\n\n    var _super4 = _createSuper(CustomEventTarget);\n\n    function CustomEventTarget() {\n      _classCallCheck(this, CustomEventTarget);\n\n      return _super4.apply(this, arguments);\n    }\n\n    return _createClass(CustomEventTarget);\n  }(EventTarget);\n\n  for (var _i7 = 0; _i7 < arguments.length; ++_i7) {\n    defineEventAttribute(CustomEventTarget.prototype, _i7 < 0 || arguments.length <= _i7 ? undefined : arguments[_i7]);\n  }\n\n  return CustomEventTarget;\n}\n\nfunction defineEventAttribute(target, type, _eventClass) {\n  Object.defineProperty(target, \"on\" + type, {\n    get: function get() {\n      return getEventAttributeValue(this, type);\n    },\n    set: function set(value) {\n      setEventAttributeValue(this, type, value);\n    },\n    configurable: true,\n    enumerable: true\n  });\n}\n\nexports.Event = Event;\nexports.EventTarget = EventTarget;\nexports.default = EventTarget;\nexports.defineCustomEventTarget = defineCustomEventTarget;\nexports.defineEventAttribute = defineEventAttribute;\nexports.getEventAttributeValue = getEventAttributeValue;\nexports.setErrorHandler = setErrorHandler;\nexports.setEventAttributeValue = setEventAttributeValue;\nexports.setWarningHandler = setWarningHandler;","map":{"version":3,"sources":["../src/lib/misc.ts","../src/lib/error-handler.ts","../src/lib/global.ts","../src/lib/warning-handler.ts","../src/lib/warnings.ts","../src/lib/event.ts","../src/lib/dom-exception.ts","../src/lib/event-wrapper.ts","../src/lib/listener.ts","../src/lib/listener-list.ts","../src/lib/listener-list-map.ts","../src/lib/event-target.ts","../src/lib/event-attribute-handler.ts","../src/lib/legacy.ts"],"names":["internalDataMap","$","getEventInternalData","keys","getEventTargetInternalData"],"mappings":"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","sourcesContent":["/**\n * Assert a condition.\n * @param condition The condition that it should satisfy.\n * @param message The error message.\n * @param args The arguments for replacing placeholders in the message.\n */\nexport function assertType(\n    condition: boolean,\n    message: string,\n    ...args: any[]\n): asserts condition {\n    if (!condition) {\n        throw new TypeError(format(message, args))\n    }\n}\n\n/**\n * Convert a text and arguments to one string.\n * @param message The formating text\n * @param args The arguments.\n */\nexport function format(message: string, args: any[]): string {\n    let i = 0\n    return message.replace(/%[os]/gu, () => anyToString(args[i++]))\n}\n\n/**\n * Convert a value to a string representation.\n * @param x The value to get the string representation.\n */\nexport function anyToString(x: any): string {\n    if (typeof x !== \"object\" || x === null) {\n        return String(x)\n    }\n    return Object.prototype.toString.call(x)\n}\n","import { anyToString, assertType } from \"./misc\"\n\ndeclare const console: any\ndeclare const dispatchEvent: any\ndeclare const ErrorEvent: any\ndeclare const process: any\n\nlet currentErrorHandler: setErrorHandler.ErrorHandler | undefined\n\n/**\n * Set the error handler.\n * @param value The error handler to set.\n */\nexport function setErrorHandler(\n    value: setErrorHandler.ErrorHandler | undefined,\n): void {\n    assertType(\n        typeof value === \"function\" || value === undefined,\n        \"The error handler must be a function or undefined, but got %o.\",\n        value,\n    )\n    currentErrorHandler = value\n}\nexport namespace setErrorHandler {\n    /**\n     * The error handler.\n     * @param error The thrown error object.\n     */\n    export type ErrorHandler = (error: Error) => void\n}\n\n/**\n * Print a error message.\n * @param maybeError The error object.\n */\nexport function reportError(maybeError: unknown): void {\n    try {\n        const error =\n            maybeError instanceof Error\n                ? maybeError\n                : new Error(anyToString(maybeError))\n\n        // Call the user-defined error handler if exists.\n        if (currentErrorHandler) {\n            currentErrorHandler(error)\n            return\n        }\n\n        // Dispatch an `error` event if this is on a browser.\n        if (\n            typeof dispatchEvent === \"function\" &&\n            typeof ErrorEvent === \"function\"\n        ) {\n            dispatchEvent(\n                new ErrorEvent(\"error\", { error, message: error.message }),\n            )\n        }\n\n        // Emit an `uncaughtException` event if this is on Node.js.\n        //istanbul ignore else\n        else if (\n            typeof process !== \"undefined\" &&\n            typeof process.emit === \"function\"\n        ) {\n            process.emit(\"uncaughtException\", error)\n            return\n        }\n\n        // Otherwise, print the error.\n        console.error(error)\n    } catch {\n        // ignore.\n    }\n}\n","declare const globalThis: any\ndeclare const window: any\ndeclare const self: any\ndeclare const global: any\n\n/**\n * The global object.\n */\n//istanbul ignore next\nexport const Global: any =\n    typeof window !== \"undefined\"\n        ? window\n        : typeof self !== \"undefined\"\n        ? self\n        : typeof global !== \"undefined\"\n        ? global\n        : typeof globalThis !== \"undefined\"\n        ? globalThis\n        : undefined\n","import { assertType } from \"./misc\"\n\ndeclare const console: any\n\nlet currentWarnHandler: setWarningHandler.WarningHandler | undefined\n\n/**\n * Set the warning handler.\n * @param value The warning handler to set.\n */\nexport function setWarningHandler(\n    value: setWarningHandler.WarningHandler | undefined,\n): void {\n    assertType(\n        typeof value === \"function\" || value === undefined,\n        \"The warning handler must be a function or undefined, but got %o.\",\n        value,\n    )\n    currentWarnHandler = value\n}\nexport namespace setWarningHandler {\n    /**\n     * The warning information.\n     */\n    export interface Warning {\n        /**\n         * The code of this warning.\n         */\n        code: string\n        /**\n         * The message in English.\n         */\n        message: string\n        /**\n         * The arguments for replacing placeholders in the text.\n         */\n        args: any[]\n    }\n\n    /**\n     * The warning handler.\n     * @param warning The warning.\n     */\n    export type WarningHandler = (warning: Warning) => void\n}\n\n/**\n * The warning information.\n */\nexport class Warning<TArgs extends any[]> {\n    readonly code: string\n    readonly message: string\n\n    constructor(code: string, message: string) {\n        this.code = code\n        this.message = message\n    }\n\n    /**\n     * Report this warning.\n     * @param args The arguments of the warning.\n     */\n    warn(...args: TArgs): void {\n        try {\n            // Call the user-defined warning handler if exists.\n            if (currentWarnHandler) {\n                currentWarnHandler({ ...this, args })\n                return\n            }\n\n            // Otherwise, print the warning.\n            const stack = (new Error().stack ?? \"\").replace(\n                /^(?:.+?\\n){2}/gu,\n                \"\\n\",\n            )\n            console.warn(this.message, ...args, stack)\n        } catch {\n            // Ignore.\n        }\n    }\n}\n","import { EventTarget } from \"./event-target\" // Used as only type, so no circular.\nimport { Warning } from \"./warning-handler\"\n\nexport const InitEventWasCalledWhileDispatching = new Warning<[]>(\n    \"W01\",\n    \"Unable to initialize event under dispatching.\",\n)\n\nexport const FalsyWasAssignedToCancelBubble = new Warning<[]>(\n    \"W02\",\n    \"Assigning any falsy value to 'cancelBubble' property has no effect.\",\n)\n\nexport const TruthyWasAssignedToReturnValue = new Warning<[]>(\n    \"W03\",\n    \"Assigning any truthy value to 'returnValue' property has no effect.\",\n)\n\nexport const NonCancelableEventWasCanceled = new Warning<[]>(\n    \"W04\",\n    \"Unable to preventDefault on non-cancelable events.\",\n)\n\nexport const CanceledInPassiveListener = new Warning<[]>(\n    \"W05\",\n    \"Unable to preventDefault inside passive event listener invocation.\",\n)\n\nexport const EventListenerWasDuplicated = new Warning<\n    [type: \"bubble\" | \"capture\", callback: EventTarget.EventListener<any, any>]\n>(\n    \"W06\",\n    \"An event listener wasn't added because it has been added already: %o, %o\",\n)\n\nexport const OptionWasIgnored = new Warning<\n    [name: \"passive\" | \"once\" | \"signal\"]\n>(\n    \"W07\",\n    \"The %o option value was abandoned because the event listener wasn't added as duplicated.\",\n)\n\nexport const InvalidEventListener = new Warning<\n    [callback: EventTarget.EventListener<any, any> | {} | null | undefined]\n>(\n    \"W08\",\n    \"The 'callback' argument must be a function or an object that has 'handleEvent' method: %o\",\n)\n\nexport const InvalidAttributeHandler = new Warning<\n    [callback: EventTarget.EventListener<any, any> | {}]\n>(\"W09\", \"Event attribute handler must be a function: %o\")\n","import { EventTarget } from \"./event-target\" // Used as only type, so no circular.\nimport { Global } from \"./global\"\nimport { assertType } from \"./misc\"\nimport {\n    CanceledInPassiveListener,\n    FalsyWasAssignedToCancelBubble,\n    InitEventWasCalledWhileDispatching,\n    NonCancelableEventWasCanceled,\n    TruthyWasAssignedToReturnValue,\n} from \"./warnings\"\n\n/*eslint-disable class-methods-use-this */\n\n/**\n * An implementation of `Event` interface, that wraps a given event object.\n * `EventTarget` shim can control the internal state of this `Event` objects.\n * @see https://dom.spec.whatwg.org/#event\n */\nexport class Event<TEventType extends string = string> {\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-none\n     */\n    static get NONE(): number {\n        return NONE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-capturing_phase\n     */\n    static get CAPTURING_PHASE(): number {\n        return CAPTURING_PHASE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-at_target\n     */\n    static get AT_TARGET(): number {\n        return AT_TARGET\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbling_phase\n     */\n    static get BUBBLING_PHASE(): number {\n        return BUBBLING_PHASE\n    }\n\n    /**\n     * Initialize this event instance.\n     * @param type The type of this event.\n     * @param eventInitDict Options to initialize.\n     * @see https://dom.spec.whatwg.org/#dom-event-event\n     */\n    constructor(type: TEventType, eventInitDict?: Event.EventInit) {\n        Object.defineProperty(this, \"isTrusted\", {\n            value: false,\n            enumerable: true,\n        })\n\n        const opts = eventInitDict ?? {}\n        internalDataMap.set(this, {\n            type: String(type),\n            bubbles: Boolean(opts.bubbles),\n            cancelable: Boolean(opts.cancelable),\n            composed: Boolean(opts.composed),\n            target: null,\n            currentTarget: null,\n            stopPropagationFlag: false,\n            stopImmediatePropagationFlag: false,\n            canceledFlag: false,\n            inPassiveListenerFlag: false,\n            dispatchFlag: false,\n            timeStamp: Date.now(),\n        })\n    }\n\n    /**\n     * The type of this event.\n     * @see https://dom.spec.whatwg.org/#dom-event-type\n     */\n    get type(): TEventType {\n        return $(this).type as TEventType\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * @see https://dom.spec.whatwg.org/#dom-event-target\n     */\n    get target(): EventTarget | null {\n        return $(this).target\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * @deprecated Use the `target` property instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-srcelement\n     */\n    get srcElement(): EventTarget | null {\n        return $(this).target\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * @see https://dom.spec.whatwg.org/#dom-event-currenttarget\n     */\n    get currentTarget(): EventTarget | null {\n        return $(this).currentTarget\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * This doesn't support node tree.\n     * @see https://dom.spec.whatwg.org/#dom-event-composedpath\n     */\n    composedPath(): EventTarget[] {\n        const currentTarget = $(this).currentTarget\n        if (currentTarget) {\n            return [currentTarget]\n        }\n        return []\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-none\n     */\n    get NONE(): number {\n        return NONE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-capturing_phase\n     */\n    get CAPTURING_PHASE(): number {\n        return CAPTURING_PHASE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-at_target\n     */\n    get AT_TARGET(): number {\n        return AT_TARGET\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbling_phase\n     */\n    get BUBBLING_PHASE(): number {\n        return BUBBLING_PHASE\n    }\n\n    /**\n     * The current event phase.\n     * @see https://dom.spec.whatwg.org/#dom-event-eventphase\n     */\n    get eventPhase(): number {\n        return $(this).dispatchFlag ? 2 : 0\n    }\n\n    /**\n     * Stop event bubbling.\n     * Because this shim doesn't support node tree, this merely changes the `cancelBubble` property value.\n     * @see https://dom.spec.whatwg.org/#dom-event-stoppropagation\n     */\n    stopPropagation(): void {\n        $(this).stopPropagationFlag = true\n    }\n\n    /**\n     * `true` if event bubbling was stopped.\n     * @deprecated\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelbubble\n     */\n    get cancelBubble(): boolean {\n        return $(this).stopPropagationFlag\n    }\n\n    /**\n     * Stop event bubbling if `true` is set.\n     * @deprecated Use the `stopPropagation()` method instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelbubble\n     */\n    set cancelBubble(value: boolean) {\n        if (value) {\n            $(this).stopPropagationFlag = true\n        } else {\n            FalsyWasAssignedToCancelBubble.warn()\n        }\n    }\n\n    /**\n     * Stop event bubbling and subsequent event listener callings.\n     * @see https://dom.spec.whatwg.org/#dom-event-stopimmediatepropagation\n     */\n    stopImmediatePropagation(): void {\n        const data = $(this)\n        data.stopPropagationFlag = data.stopImmediatePropagationFlag = true\n    }\n\n    /**\n     * `true` if this event will bubble.\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbles\n     */\n    get bubbles(): boolean {\n        return $(this).bubbles\n    }\n\n    /**\n     * `true` if this event can be canceled by the `preventDefault()` method.\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelable\n     */\n    get cancelable(): boolean {\n        return $(this).cancelable\n    }\n\n    /**\n     * `true` if the default behavior will act.\n     * @deprecated Use the `defaultPrevented` proeprty instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-returnvalue\n     */\n    get returnValue(): boolean {\n        return !$(this).canceledFlag\n    }\n\n    /**\n     * Cancel the default behavior if `false` is set.\n     * @deprecated Use the `preventDefault()` method instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-returnvalue\n     */\n    set returnValue(value: boolean) {\n        if (!value) {\n            setCancelFlag($(this))\n        } else {\n            TruthyWasAssignedToReturnValue.warn()\n        }\n    }\n\n    /**\n     * Cancel the default behavior.\n     * @see https://dom.spec.whatwg.org/#dom-event-preventdefault\n     */\n    preventDefault(): void {\n        setCancelFlag($(this))\n    }\n\n    /**\n     * `true` if the default behavior was canceled.\n     * @see https://dom.spec.whatwg.org/#dom-event-defaultprevented\n     */\n    get defaultPrevented(): boolean {\n        return $(this).canceledFlag\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     */\n    get composed(): boolean {\n        return $(this).composed\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-istrusted\n     */\n    //istanbul ignore next\n    get isTrusted(): boolean {\n        return false\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-timestamp\n     */\n    get timeStamp(): number {\n        return $(this).timeStamp\n    }\n\n    /**\n     * @deprecated Don't use this method. The constructor did initialization.\n     */\n    initEvent(type: string, bubbles = false, cancelable = false) {\n        const data = $(this)\n        if (data.dispatchFlag) {\n            InitEventWasCalledWhileDispatching.warn()\n            return\n        }\n\n        internalDataMap.set(this, {\n            ...data,\n            type: String(type),\n            bubbles: Boolean(bubbles),\n            cancelable: Boolean(cancelable),\n            target: null,\n            currentTarget: null,\n            stopPropagationFlag: false,\n            stopImmediatePropagationFlag: false,\n            canceledFlag: false,\n        })\n    }\n}\n\n/*eslint-enable class-methods-use-this */\n\nexport namespace Event {\n    /**\n     * The options of the `Event` constructor.\n     * @see https://dom.spec.whatwg.org/#dictdef-eventinit\n     */\n    export interface EventInit {\n        bubbles?: boolean\n        cancelable?: boolean\n        composed?: boolean\n    }\n}\n\nexport { $ as getEventInternalData }\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst NONE = 0\nconst CAPTURING_PHASE = 1\nconst AT_TARGET = 2\nconst BUBBLING_PHASE = 3\n\n/**\n * Private data.\n */\ninterface EventInternalData {\n    /**\n     * The value of `type` attribute.\n     */\n    readonly type: string\n    /**\n     * The value of `bubbles` attribute.\n     */\n    readonly bubbles: boolean\n    /**\n     * The value of `cancelable` attribute.\n     */\n    readonly cancelable: boolean\n    /**\n     * The value of `composed` attribute.\n     */\n    readonly composed: boolean\n    /**\n     * The value of `timeStamp` attribute.\n     */\n    readonly timeStamp: number\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-target\n     */\n    target: EventTarget | null\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-currenttarget\n     */\n    currentTarget: EventTarget | null\n    /**\n     * @see https://dom.spec.whatwg.org/#stop-propagation-flag\n     */\n    stopPropagationFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#stop-immediate-propagation-flag\n     */\n    stopImmediatePropagationFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#canceled-flag\n     */\n    canceledFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#in-passive-listener-flag\n     */\n    inPassiveListenerFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#dispatch-flag\n     */\n    dispatchFlag: boolean\n}\n\n/**\n * Private data for event wrappers.\n */\nconst internalDataMap = new WeakMap<any, EventInternalData>()\n\n/**\n * Get private data.\n * @param event The event object to get private data.\n * @param name The variable name to report.\n * @returns The private data of the event.\n */\nfunction $(event: unknown, name = \"this\"): EventInternalData {\n    const retv = internalDataMap.get(event)\n    assertType(\n        retv != null,\n        \"'%s' must be an object that Event constructor created, but got another one: %o\",\n        name,\n        event,\n    )\n    return retv\n}\n\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data private data.\n */\nfunction setCancelFlag(data: EventInternalData) {\n    if (data.inPassiveListenerFlag) {\n        CanceledInPassiveListener.warn()\n        return\n    }\n    if (!data.cancelable) {\n        NonCancelableEventWasCanceled.warn()\n        return\n    }\n\n    data.canceledFlag = true\n}\n\n// Set enumerable\nObject.defineProperty(Event, \"NONE\", { enumerable: true })\nObject.defineProperty(Event, \"CAPTURING_PHASE\", { enumerable: true })\nObject.defineProperty(Event, \"AT_TARGET\", { enumerable: true })\nObject.defineProperty(Event, \"BUBBLING_PHASE\", { enumerable: true })\nconst keys = Object.getOwnPropertyNames(Event.prototype)\nfor (let i = 0; i < keys.length; ++i) {\n    if (keys[i] === \"constructor\") {\n        continue\n    }\n    Object.defineProperty(Event.prototype, keys[i], { enumerable: true })\n}\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof Global !== \"undefined\" && typeof Global.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, Global.Event.prototype)\n}\n","import { Global } from \"./global\"\n\n/**\n * Create a new InvalidStateError instance.\n * @param message The error message.\n */\nexport function createInvalidStateError(message: string): Error {\n    if (Global.DOMException) {\n        return new Global.DOMException(message, \"InvalidStateError\")\n    }\n\n    if (DOMException == null) {\n        DOMException = class DOMException extends Error {\n            constructor(msg: string) {\n                super(msg)\n                if ((Error as any).captureStackTrace) {\n                    ;(Error as any).captureStackTrace(this, DOMException)\n                }\n            }\n            // eslint-disable-next-line class-methods-use-this\n            get code() {\n                return 11\n            }\n            // eslint-disable-next-line class-methods-use-this\n            get name() {\n                return \"InvalidStateError\"\n            }\n        }\n        Object.defineProperties(DOMException.prototype, {\n            code: { enumerable: true },\n            name: { enumerable: true },\n        })\n        defineErrorCodeProperties(DOMException)\n        defineErrorCodeProperties(DOMException.prototype)\n    }\n    return new DOMException(message)\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nlet DOMException: { new (message: string): Error } | undefined\n\nconst ErrorCodeMap = {\n    INDEX_SIZE_ERR: 1,\n    DOMSTRING_SIZE_ERR: 2,\n    HIERARCHY_REQUEST_ERR: 3,\n    WRONG_DOCUMENT_ERR: 4,\n    INVALID_CHARACTER_ERR: 5,\n    NO_DATA_ALLOWED_ERR: 6,\n    NO_MODIFICATION_ALLOWED_ERR: 7,\n    NOT_FOUND_ERR: 8,\n    NOT_SUPPORTED_ERR: 9,\n    INUSE_ATTRIBUTE_ERR: 10,\n    INVALID_STATE_ERR: 11,\n    SYNTAX_ERR: 12,\n    INVALID_MODIFICATION_ERR: 13,\n    NAMESPACE_ERR: 14,\n    INVALID_ACCESS_ERR: 15,\n    VALIDATION_ERR: 16,\n    TYPE_MISMATCH_ERR: 17,\n    SECURITY_ERR: 18,\n    NETWORK_ERR: 19,\n    ABORT_ERR: 20,\n    URL_MISMATCH_ERR: 21,\n    QUOTA_EXCEEDED_ERR: 22,\n    TIMEOUT_ERR: 23,\n    INVALID_NODE_TYPE_ERR: 24,\n    DATA_CLONE_ERR: 25,\n}\ntype ErrorCodeMap = typeof ErrorCodeMap\n\nfunction defineErrorCodeProperties(obj: any): void {\n    const keys = Object.keys(ErrorCodeMap) as (keyof ErrorCodeMap)[]\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        const value = ErrorCodeMap[key]\n        Object.defineProperty(obj, key, {\n            get() {\n                return value\n            },\n            configurable: true,\n            enumerable: true,\n        })\n    }\n}\n","import { Event } from \"./event\"\nimport { Global } from \"./global\"\nimport { assertType } from \"./misc\"\n\n/**\n * An implementation of `Event` interface, that wraps a given event object.\n * This class controls the internal state of `Event`.\n * @see https://dom.spec.whatwg.org/#interface-event\n */\nexport class EventWrapper<TEventType extends string> extends Event<TEventType> {\n    /**\n     * Wrap a given event object to control states.\n     * @param event The event-like object to wrap.\n     */\n    static wrap<T extends EventLike>(event: T): EventWrapperOf<T> {\n        return new (getWrapperClassOf(event))(event)\n    }\n\n    protected constructor(event: Event<TEventType>) {\n        super(event.type, {\n            bubbles: event.bubbles,\n            cancelable: event.cancelable,\n            composed: event.composed,\n        })\n\n        if (event.cancelBubble) {\n            super.stopPropagation()\n        }\n        if (event.defaultPrevented) {\n            super.preventDefault()\n        }\n\n        internalDataMap.set(this, { original: event })\n\n        // Define accessors\n        const keys = Object.keys(event)\n        for (let i = 0; i < keys.length; ++i) {\n            const key = keys[i]\n            if (!(key in this)) {\n                Object.defineProperty(\n                    this,\n                    key,\n                    defineRedirectDescriptor(event, key),\n                )\n            }\n        }\n    }\n\n    stopPropagation(): void {\n        super.stopPropagation()\n\n        const { original } = $(this)\n        if (\"stopPropagation\" in original) {\n            original.stopPropagation!()\n        }\n    }\n\n    get cancelBubble(): boolean {\n        return super.cancelBubble\n    }\n    set cancelBubble(value: boolean) {\n        super.cancelBubble = value\n\n        const { original } = $(this)\n        if (\"cancelBubble\" in original) {\n            original.cancelBubble = value\n        }\n    }\n\n    stopImmediatePropagation(): void {\n        super.stopImmediatePropagation()\n\n        const { original } = $(this)\n        if (\"stopImmediatePropagation\" in original) {\n            original.stopImmediatePropagation!()\n        }\n    }\n\n    get returnValue(): boolean {\n        return super.returnValue\n    }\n    set returnValue(value: boolean) {\n        super.returnValue = value\n\n        const { original } = $(this)\n        if (\"returnValue\" in original) {\n            original.returnValue = value\n        }\n    }\n\n    preventDefault(): void {\n        super.preventDefault()\n\n        const { original } = $(this)\n        if (\"preventDefault\" in original) {\n            original.preventDefault!()\n        }\n    }\n\n    get timeStamp(): number {\n        const { original } = $(this)\n        if (\"timeStamp\" in original) {\n            return original.timeStamp!\n        }\n        return super.timeStamp\n    }\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\ntype EventLike = { readonly type: string } & Partial<Event>\ntype EventWrapperOf<T extends EventLike> = Event<T[\"type\"]> &\n    Omit<T, keyof Event>\n\ninterface EventWrapperInternalData {\n    readonly original: EventLike\n}\n\n/**\n * Private data for event wrappers.\n */\nconst internalDataMap = new WeakMap<any, EventWrapperInternalData>()\n\n/**\n * Get private data.\n * @param event The event object to get private data.\n * @returns The private data of the event.\n */\nfunction $(event: unknown): EventWrapperInternalData {\n    const retv = internalDataMap.get(event)\n    assertType(\n        retv != null,\n        \"'this' is expected an Event object, but got\",\n        event,\n    )\n    return retv\n}\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrapperClassCache = new WeakMap()\n\n// Make association for wrappers.\nwrapperClassCache.set(Object.prototype, EventWrapper)\nif (typeof Global !== \"undefined\" && typeof Global.Event !== \"undefined\") {\n    wrapperClassCache.set(Global.Event.prototype, EventWrapper)\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param originalEvent The event object to wrap.\n */\nfunction getWrapperClassOf<T extends EventLike>(\n    originalEvent: T,\n): { new (e: T): EventWrapperOf<T> } {\n    const prototype = Object.getPrototypeOf(originalEvent)\n    if (prototype == null) {\n        return EventWrapper as any\n    }\n\n    let wrapper: any = wrapperClassCache.get(prototype)\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapperClassOf(prototype), prototype)\n        wrapperClassCache.set(prototype, wrapper)\n    }\n\n    return wrapper\n}\n\n/**\n * Define new wrapper class.\n * @param BaseEventWrapper The base wrapper class.\n * @param originalPrototype The prototype of the original event.\n */\nfunction defineWrapper(BaseEventWrapper: any, originalPrototype: any): any {\n    class CustomEventWrapper extends BaseEventWrapper {}\n\n    const keys = Object.keys(originalPrototype)\n    for (let i = 0; i < keys.length; ++i) {\n        Object.defineProperty(\n            CustomEventWrapper.prototype,\n            keys[i],\n            defineRedirectDescriptor(originalPrototype, keys[i]),\n        )\n    }\n\n    return CustomEventWrapper\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n */\nfunction defineRedirectDescriptor(obj: any, key: string): PropertyDescriptor {\n    const d = Object.getOwnPropertyDescriptor(obj, key)!\n    return {\n        get() {\n            const original: any = $(this).original\n            const value = original[key]\n            if (typeof value === \"function\") {\n                return value.bind(original)\n            }\n            return value\n        },\n        set(value: any) {\n            const original: any = $(this).original\n            original[key] = value\n        },\n        configurable: d.configurable,\n        enumerable: d.enumerable,\n    }\n}\n","import { reportError } from \"./error-handler\"\nimport { Event } from \"./event\" // Used as only type, so no circular.\nimport { EventTarget } from \"./event-target\" // Used as only type, so no circular.\n\n/**\n * The event listener concept.\n * @see https://dom.spec.whatwg.org/#concept-event-listener\n */\nexport interface Listener {\n    /**\n     * The callback function.\n     */\n    readonly callback: Listener.Callback<any, any>\n    /**\n     * The flags of this listener.\n     * This is writable to add the removed flag.\n     */\n    flags: ListenerFlags\n    /**\n     * The `AbortSignal` to remove this listener.\n     */\n    readonly signal: Listener.AbortSignal | undefined\n    /**\n     * The `abort` event listener for the `signal`.\n     * To remove it from the `signal`.\n     */\n    readonly signalListener: (() => void) | undefined\n}\n\nexport namespace Listener {\n    export type Callback<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > = CallbackFunction<TEventTarget, TEvent> | CallbackObject<TEvent>\n\n    export interface CallbackFunction<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > {\n        (this: TEventTarget, event: TEvent): void\n    }\n\n    export interface CallbackObject<TEvent extends Event> {\n        handleEvent(event: TEvent): void\n    }\n\n    export interface AbortSignal {\n        addEventListener(type: string, callback: Callback<any, Event>): void\n        removeEventListener(type: string, callback: Callback<any, Event>): void\n    }\n}\n\n/**\n * Create a new listener.\n * @param callback The callback function.\n * @param capture The capture flag.\n * @param passive The passive flag.\n * @param once The once flag.\n * @param signal The abort signal.\n * @param signalListener The abort event listener for the abort signal.\n */\nexport function createListener(\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n    passive: boolean,\n    once: boolean,\n    signal: Listener.AbortSignal | undefined,\n    signalListener: (() => void) | undefined,\n): Listener {\n    return {\n        callback,\n        flags:\n            (capture ? ListenerFlags.Capture : 0) |\n            (passive ? ListenerFlags.Passive : 0) |\n            (once ? ListenerFlags.Once : 0),\n        signal,\n        signalListener,\n    }\n}\n\n/**\n * Set the `removed` flag to the given listener.\n * @param listener The listener to check.\n */\nexport function setRemoved(listener: Listener): void {\n    listener.flags |= ListenerFlags.Removed\n}\n\n/**\n * Check if the given listener has the `capture` flag or not.\n * @param listener The listener to check.\n */\nexport function isCapture(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Capture) === ListenerFlags.Capture\n}\n\n/**\n * Check if the given listener has the `passive` flag or not.\n * @param listener The listener to check.\n */\nexport function isPassive(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Passive) === ListenerFlags.Passive\n}\n\n/**\n * Check if the given listener has the `once` flag or not.\n * @param listener The listener to check.\n */\nexport function isOnce(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Once) === ListenerFlags.Once\n}\n\n/**\n * Check if the given listener has the `removed` flag or not.\n * @param listener The listener to check.\n */\nexport function isRemoved(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Removed) === ListenerFlags.Removed\n}\n\n/**\n * Call an event listener.\n * @param listener The listener to call.\n * @param target The event target object for `thisArg`.\n * @param event The event object for the first argument.\n * @param attribute `true` if this callback is an event attribute handler.\n */\nexport function invokeCallback(\n    { callback }: Listener,\n    target: EventTarget<any, any>,\n    event: Event<any>,\n): void {\n    try {\n        if (typeof callback === \"function\") {\n            callback.call(target, event)\n        } else if (typeof callback.handleEvent === \"function\") {\n            callback.handleEvent(event)\n        }\n    } catch (thrownError) {\n        reportError(thrownError)\n    }\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * The flags of listeners.\n */\nconst enum ListenerFlags {\n    Capture = 0x01,\n    Passive = 0x02,\n    Once = 0x04,\n    Removed = 0x08,\n}\n","import { createListener, isCapture, Listener, setRemoved } from \"./listener\"\n\n/**\n * Information of an listener list.\n */\nexport interface ListenerList {\n    /**\n     * The callback function of the event attribute handler.\n     */\n    attrCallback: Listener.CallbackFunction<any, any> | undefined\n    /**\n     * The listener of the event attribute handler.\n     */\n    attrListener: Listener | undefined\n    /**\n     * `true` if the `dispatchEvent` method is traversing the current `listeners` array.\n     */\n    cow: boolean\n    /**\n     * The listeners.\n     * This is writable for copy-on-write.\n     */\n    listeners: Listener[]\n}\n\n/**\n * Find the index of given listener.\n * This returns `-1` if not found.\n * @param list The listener list.\n * @param callback The callback function to find.\n * @param capture The capture flag to find.\n */\nexport function findIndexOfListener(\n    { listeners }: ListenerList,\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n): number {\n    for (let i = 0; i < listeners.length; ++i) {\n        if (\n            listeners[i].callback === callback &&\n            isCapture(listeners[i]) === capture\n        ) {\n            return i\n        }\n    }\n    return -1\n}\n\n/**\n * Add the given listener.\n * Does copy-on-write if needed.\n * @param list The listener list.\n * @param callback The callback function.\n * @param capture The capture flag.\n * @param passive The passive flag.\n * @param once The once flag.\n * @param signal The abort signal.\n */\nexport function addListener(\n    list: ListenerList,\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n    passive: boolean,\n    once: boolean,\n    signal: Listener.AbortSignal | undefined,\n): Listener {\n    let signalListener: (() => void) | undefined\n    if (signal) {\n        signalListener = removeListener.bind(null, list, callback, capture)\n        signal.addEventListener(\"abort\", signalListener)\n    }\n\n    const listener = createListener(\n        callback,\n        capture,\n        passive,\n        once,\n        signal,\n        signalListener,\n    )\n\n    if (list.cow) {\n        list.cow = false\n        list.listeners = [...list.listeners, listener]\n    } else {\n        list.listeners.push(listener)\n    }\n\n    return listener\n}\n\n/**\n * Remove a listener.\n * @param list The listener list.\n * @param callback The callback function to find.\n * @param capture The capture flag to find.\n * @returns `true` if it mutated the list directly.\n */\nexport function removeListener(\n    list: ListenerList,\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n): boolean {\n    const index = findIndexOfListener(list, callback, capture)\n    if (index !== -1) {\n        return removeListenerAt(list, index)\n    }\n    return false\n}\n\n/**\n * Remove a listener.\n * @param list The listener list.\n * @param index The index of the target listener.\n * @param disableCow Disable copy-on-write if true.\n * @returns `true` if it mutated the `listeners` array directly.\n */\nexport function removeListenerAt(\n    list: ListenerList,\n    index: number,\n    disableCow = false,\n): boolean {\n    const listener = list.listeners[index]\n\n    // Set the removed flag.\n    setRemoved(listener)\n\n    // Dispose the abort signal listener if exists.\n    if (listener.signal) {\n        listener.signal.removeEventListener(\"abort\", listener.signalListener!)\n    }\n\n    // Remove it from the array.\n    if (list.cow && !disableCow) {\n        list.cow = false\n        list.listeners = list.listeners.filter((_, i) => i !== index)\n        return false\n    }\n    list.listeners.splice(index, 1)\n    return true\n}\n","import { ListenerList } from \"./listener-list\"\n\n/**\n * The map from event types to each listener list.\n */\nexport interface ListenerListMap {\n    [type: string]: ListenerList | undefined\n}\n\n/**\n * Create a new `ListenerListMap` object.\n */\nexport function createListenerListMap(): ListenerListMap {\n    return Object.create(null)\n}\n\n/**\n * Get the listener list of the given type.\n * If the listener list has not been initialized, initialize and return it.\n * @param listenerMap The listener list map.\n * @param type The event type to get.\n */\nexport function ensureListenerList(\n    listenerMap: Record<string, ListenerList | undefined>,\n    type: string,\n): ListenerList {\n    return (listenerMap[type] ??= {\n        attrCallback: undefined,\n        attrListener: undefined,\n        cow: false,\n        listeners: [],\n    })\n}\n","import { createInvalidStateError } from \"./dom-exception\"\nimport { Event, getEventInternalData } from \"./event\"\nimport { EventWrapper } from \"./event-wrapper\"\nimport { Global } from \"./global\"\nimport {\n    invokeCallback,\n    isCapture,\n    isOnce,\n    isPassive,\n    isRemoved,\n    Listener,\n} from \"./listener\"\nimport {\n    addListener,\n    findIndexOfListener,\n    removeListener,\n    removeListenerAt,\n} from \"./listener-list\"\nimport {\n    createListenerListMap,\n    ensureListenerList,\n    ListenerListMap,\n} from \"./listener-list-map\"\nimport { assertType, format } from \"./misc\"\nimport {\n    EventListenerWasDuplicated,\n    InvalidEventListener,\n    OptionWasIgnored,\n} from \"./warnings\"\n\n/**\n * An implementation of the `EventTarget` interface.\n * @see https://dom.spec.whatwg.org/#eventtarget\n */\nexport class EventTarget<\n    TEventMap extends Record<string, Event> = Record<string, Event>,\n    TMode extends \"standard\" | \"strict\" = \"standard\"\n> {\n    /**\n     * Initialize this instance.\n     */\n    constructor() {\n        internalDataMap.set(this, createListenerListMap())\n    }\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    addEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options?: EventTarget.AddOptions,\n    ): void\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    addEventListener(\n        type: string,\n        callback?: EventTarget.FallbackEventListener<this, TMode>,\n        options?: EventTarget.AddOptions,\n    ): void\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    addEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback:\n            | EventTarget.EventListener<this, TEventMap[T]>\n            | null\n            | undefined,\n        capture: boolean,\n    ): void\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    addEventListener(\n        type: string,\n        callback: EventTarget.FallbackEventListener<this, TMode>,\n        capture: boolean,\n    ): void\n\n    // Implementation\n    addEventListener<T extends string & keyof TEventMap>(\n        type0: T,\n        callback0?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options0?: boolean | EventTarget.AddOptions,\n    ): void {\n        const listenerMap = $(this)\n        const {\n            callback,\n            capture,\n            once,\n            passive,\n            signal,\n            type,\n        } = normalizeAddOptions(type0, callback0, options0)\n        if (callback == null || signal?.aborted) {\n            return\n        }\n        const list = ensureListenerList(listenerMap, type)\n\n        // Find existing listener.\n        const i = findIndexOfListener(list, callback, capture)\n        if (i !== -1) {\n            warnDuplicate(list.listeners[i], passive, once, signal)\n            return\n        }\n\n        // Add the new listener.\n        addListener(list, callback, capture, passive, once, signal)\n    }\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    removeEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options?: EventTarget.Options,\n    ): void\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    removeEventListener(\n        type: string,\n        callback?: EventTarget.FallbackEventListener<this, TMode>,\n        options?: EventTarget.Options,\n    ): void\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    removeEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback:\n            | EventTarget.EventListener<this, TEventMap[T]>\n            | null\n            | undefined,\n        capture: boolean,\n    ): void\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    removeEventListener(\n        type: string,\n        callback: EventTarget.FallbackEventListener<this, TMode>,\n        capture: boolean,\n    ): void\n\n    // Implementation\n    removeEventListener<T extends string & keyof TEventMap>(\n        type0: T,\n        callback0?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options0?: boolean | EventTarget.Options,\n    ): void {\n        const listenerMap = $(this)\n        const { callback, capture, type } = normalizeOptions(\n            type0,\n            callback0,\n            options0,\n        )\n        const list = listenerMap[type]\n\n        if (callback != null && list) {\n            removeListener(list, callback, capture)\n        }\n    }\n\n    /**\n     * Dispatch an event.\n     * @param event The `Event` object to dispatch.\n     */\n    dispatchEvent<T extends string & keyof TEventMap>(\n        event: EventTarget.EventData<TEventMap, TMode, T>,\n    ): boolean\n\n    /**\n     * Dispatch an event.\n     * @param event The `Event` object to dispatch.\n     */\n    dispatchEvent(event: EventTarget.FallbackEvent<TMode>): boolean\n\n    // Implementation\n    dispatchEvent(\n        e:\n            | EventTarget.EventData<TEventMap, TMode, string>\n            | EventTarget.FallbackEvent<TMode>,\n    ): boolean {\n        const list = $(this)[String(e.type)]\n        if (list == null) {\n            return true\n        }\n\n        const event = e instanceof Event ? e : EventWrapper.wrap(e)\n        const eventData = getEventInternalData(event, \"event\")\n        if (eventData.dispatchFlag) {\n            throw createInvalidStateError(\"This event has been in dispatching.\")\n        }\n\n        eventData.dispatchFlag = true\n        eventData.target = eventData.currentTarget = this\n\n        if (!eventData.stopPropagationFlag) {\n            const { cow, listeners } = list\n\n            // Set copy-on-write flag.\n            list.cow = true\n\n            // Call listeners.\n            for (let i = 0; i < listeners.length; ++i) {\n                const listener = listeners[i]\n\n                // Skip if removed.\n                if (isRemoved(listener)) {\n                    continue\n                }\n\n                // Remove this listener if has the `once` flag.\n                if (isOnce(listener) && removeListenerAt(list, i, !cow)) {\n                    // Because this listener was removed, the next index is the\n                    // same as the current value.\n                    i -= 1\n                }\n\n                // Call this listener with the `passive` flag.\n                eventData.inPassiveListenerFlag = isPassive(listener)\n                invokeCallback(listener, this, event)\n                eventData.inPassiveListenerFlag = false\n\n                // Stop if the `event.stopImmediatePropagation()` method was called.\n                if (eventData.stopImmediatePropagationFlag) {\n                    break\n                }\n            }\n\n            // Restore copy-on-write flag.\n            if (!cow) {\n                list.cow = false\n            }\n        }\n\n        eventData.target = null\n        eventData.currentTarget = null\n        eventData.stopImmediatePropagationFlag = false\n        eventData.stopPropagationFlag = false\n        eventData.dispatchFlag = false\n\n        return !eventData.canceledFlag\n    }\n}\n\nexport namespace EventTarget {\n    /**\n     * The event listener.\n     */\n    export type EventListener<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > = CallbackFunction<TEventTarget, TEvent> | CallbackObject<TEvent>\n\n    /**\n     * The event listener function.\n     */\n    export interface CallbackFunction<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > {\n        (this: TEventTarget, event: TEvent): void\n    }\n\n    /**\n     * The event listener object.\n     * @see https://dom.spec.whatwg.org/#callbackdef-eventlistener\n     */\n    export interface CallbackObject<TEvent extends Event> {\n        handleEvent(event: TEvent): void\n    }\n\n    /**\n     * The common options for both `addEventListener` and `removeEventListener` methods.\n     * @see https://dom.spec.whatwg.org/#dictdef-eventlisteneroptions\n     */\n    export interface Options {\n        capture?: boolean\n    }\n\n    /**\n     * The options for the `addEventListener` methods.\n     * @see https://dom.spec.whatwg.org/#dictdef-addeventlisteneroptions\n     */\n    export interface AddOptions extends Options {\n        passive?: boolean\n        once?: boolean\n        signal?: AbortSignal | null | undefined\n    }\n\n    /**\n     * The abort signal.\n     * @see https://dom.spec.whatwg.org/#abortsignal\n     */\n    export interface AbortSignal extends EventTarget<{ abort: Event }> {\n        readonly aborted: boolean\n        onabort: CallbackFunction<this, Event> | null\n    }\n\n    /**\n     * The event data to dispatch in strict mode.\n     */\n    export type EventData<\n        TEventMap extends Record<string, Event>,\n        TMode extends \"standard\" | \"strict\",\n        TEventType extends string\n    > = TMode extends \"strict\"\n        ? IsValidEventMap<TEventMap> extends true\n            ? ExplicitType<TEventType> &\n                  Omit<TEventMap[TEventType], keyof Event> &\n                  Partial<Omit<Event, \"type\">>\n            : never\n        : never\n\n    /**\n     * Define explicit `type` property if `T` is a string literal.\n     * Otherwise, never.\n     */\n    export type ExplicitType<T extends string> = string extends T\n        ? never\n        : { readonly type: T }\n\n    /**\n     * The event listener type in standard mode.\n     * Otherwise, never.\n     */\n    export type FallbackEventListener<\n        TEventTarget extends EventTarget<any, any>,\n        TMode extends \"standard\" | \"strict\"\n    > = TMode extends \"standard\"\n        ? EventListener<TEventTarget, Event> | null | undefined\n        : never\n\n    /**\n     * The event type in standard mode.\n     * Otherwise, never.\n     */\n    export type FallbackEvent<\n        TMode extends \"standard\" | \"strict\"\n    > = TMode extends \"standard\" ? Event : never\n\n    /**\n     * Check if given event map is valid.\n     * It's valid if the keys of the event map are narrower than `string`.\n     */\n    export type IsValidEventMap<T> = string extends keyof T ? false : true\n}\n\nexport { $ as getEventTargetInternalData }\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Internal data for EventTarget\n */\ntype EventTargetInternalData = ListenerListMap\n\n/**\n * Internal data.\n */\nconst internalDataMap = new WeakMap<any, EventTargetInternalData>()\n\n/**\n * Get private data.\n * @param target The event target object to get private data.\n * @param name The variable name to report.\n * @returns The private data of the event.\n */\nfunction $(target: any, name = \"this\"): EventTargetInternalData {\n    const retv = internalDataMap.get(target)\n    assertType(\n        retv != null,\n        \"'%s' must be an object that EventTarget constructor created, but got another one: %o\",\n        name,\n        target,\n    )\n    return retv\n}\n\n/**\n * Normalize options.\n * @param options The options to normalize.\n */\nfunction normalizeAddOptions(\n    type: string,\n    callback: EventTarget.EventListener<any, any> | null | undefined,\n    options: boolean | EventTarget.AddOptions | undefined,\n): {\n    type: string\n    callback: EventTarget.EventListener<any, any> | undefined\n    capture: boolean\n    passive: boolean\n    once: boolean\n    signal: EventTarget.AbortSignal | undefined\n} {\n    assertCallback(callback)\n\n    if (typeof options === \"object\" && options !== null) {\n        return {\n            type: String(type),\n            callback: callback ?? undefined,\n            capture: Boolean(options.capture),\n            passive: Boolean(options.passive),\n            once: Boolean(options.once),\n            signal: options.signal ?? undefined,\n        }\n    }\n\n    return {\n        type: String(type),\n        callback: callback ?? undefined,\n        capture: Boolean(options),\n        passive: false,\n        once: false,\n        signal: undefined,\n    }\n}\n\n/**\n * Normalize options.\n * @param options The options to normalize.\n */\nfunction normalizeOptions(\n    type: string,\n    callback: EventTarget.EventListener<any, any> | null | undefined,\n    options: boolean | EventTarget.Options | undefined,\n): {\n    type: string\n    callback: EventTarget.EventListener<any, any> | undefined\n    capture: boolean\n} {\n    assertCallback(callback)\n\n    if (typeof options === \"object\" && options !== null) {\n        return {\n            type: String(type),\n            callback: callback ?? undefined,\n            capture: Boolean(options.capture),\n        }\n    }\n\n    return {\n        type: String(type),\n        callback: callback ?? undefined,\n        capture: Boolean(options),\n    }\n}\n\n/**\n * Assert the type of 'callback' argument.\n * @param callback The callback to check.\n */\nfunction assertCallback(callback: any): void {\n    if (\n        typeof callback === \"function\" ||\n        (typeof callback === \"object\" &&\n            callback !== null &&\n            typeof callback.handleEvent === \"function\")\n    ) {\n        return\n    }\n    if (callback == null || typeof callback === \"object\") {\n        InvalidEventListener.warn(callback)\n        return\n    }\n\n    throw new TypeError(format(InvalidEventListener.message, [callback]))\n}\n\n/**\n * Print warning for duplicated.\n * @param listener The current listener that is duplicated.\n * @param passive The passive flag of the new duplicated listener.\n * @param once The once flag of the new duplicated listener.\n * @param signal The signal object of the new duplicated listener.\n */\nfunction warnDuplicate(\n    listener: Listener,\n    passive: boolean,\n    once: boolean,\n    signal: EventTarget.AbortSignal | undefined,\n): void {\n    EventListenerWasDuplicated.warn(\n        isCapture(listener) ? \"capture\" : \"bubble\",\n        listener.callback,\n    )\n\n    if (isPassive(listener) !== passive) {\n        OptionWasIgnored.warn(\"passive\")\n    }\n    if (isOnce(listener) !== once) {\n        OptionWasIgnored.warn(\"once\")\n    }\n    if (listener.signal !== signal) {\n        OptionWasIgnored.warn(\"signal\")\n    }\n}\n\n// Set enumerable\nconst keys = Object.getOwnPropertyNames(EventTarget.prototype)\nfor (let i = 0; i < keys.length; ++i) {\n    if (keys[i] === \"constructor\") {\n        continue\n    }\n    Object.defineProperty(EventTarget.prototype, keys[i], { enumerable: true })\n}\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (\n    typeof Global !== \"undefined\" &&\n    typeof Global.EventTarget !== \"undefined\"\n) {\n    Object.setPrototypeOf(EventTarget.prototype, Global.EventTarget.prototype)\n}\n","import { Event } from \"./event\"\nimport { EventTarget, getEventTargetInternalData } from \"./event-target\"\nimport { addListener, ListenerList, removeListener } from \"./listener-list\"\nimport { ensureListenerList } from \"./listener-list-map\"\nimport { InvalidAttributeHandler } from \"./warnings\"\n\n/**\n * Get the current value of a given event attribute.\n * @param target The `EventTarget` object to get.\n * @param type The event type.\n */\nexport function getEventAttributeValue<\n    TEventTarget extends EventTarget<any, any>,\n    TEvent extends Event\n>(\n    target: TEventTarget,\n    type: string,\n): EventTarget.CallbackFunction<TEventTarget, TEvent> | null {\n    const listMap = getEventTargetInternalData(target, \"target\")\n    return listMap[type]?.attrCallback ?? null\n}\n\n/**\n * Set an event listener to a given event attribute.\n * @param target The `EventTarget` object to set.\n * @param type The event type.\n * @param callback The event listener.\n */\nexport function setEventAttributeValue(\n    target: EventTarget<any, any>,\n    type: string,\n    callback: EventTarget.CallbackFunction<any, any> | null,\n): void {\n    if (callback != null && typeof callback !== \"function\") {\n        InvalidAttributeHandler.warn(callback)\n    }\n\n    if (\n        typeof callback === \"function\" ||\n        (typeof callback === \"object\" && callback !== null)\n    ) {\n        upsertEventAttributeListener(target, type, callback)\n    } else {\n        removeEventAttributeListener(target, type)\n    }\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Update or insert the given event attribute handler.\n * @param target The `EventTarget` object to set.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction upsertEventAttributeListener<\n    TEventTarget extends EventTarget<any, any>\n>(\n    target: TEventTarget,\n    type: string,\n    callback: EventTarget.CallbackFunction<TEventTarget, any>,\n): void {\n    const list = ensureListenerList(\n        getEventTargetInternalData(target, \"target\"),\n        String(type),\n    )\n    list.attrCallback = callback\n\n    if (list.attrListener == null) {\n        list.attrListener = addListener(\n            list,\n            defineEventAttributeCallback(list),\n            false,\n            false,\n            false,\n            undefined,\n        )\n    }\n}\n\n/**\n * Remove the given event attribute handler.\n * @param target The `EventTarget` object to remove.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction removeEventAttributeListener(\n    target: EventTarget<any, any>,\n    type: string,\n): void {\n    const listMap = getEventTargetInternalData(target, \"target\")\n    const list = listMap[String(type)]\n    if (list && list.attrListener) {\n        removeListener(list, list.attrListener.callback, false)\n        list.attrCallback = list.attrListener = undefined\n    }\n}\n\n/**\n * Define the callback function for the given listener list object.\n * It calls `attrCallback` property if the property value is a function.\n * @param list The `ListenerList` object.\n */\nfunction defineEventAttributeCallback(\n    list: ListenerList,\n): EventTarget.CallbackFunction<any, any> {\n    return function (event) {\n        const callback = list.attrCallback\n        if (typeof callback === \"function\") {\n            callback.call(this, event)\n        }\n    }\n}\n","import { Event } from \"./event\"\nimport {\n    getEventAttributeValue,\n    setEventAttributeValue,\n} from \"./event-attribute-handler\"\nimport { EventTarget } from \"./event-target\"\n\n/**\n * Define an `EventTarget` class that has event attibutes.\n * @param types The types to define event attributes.\n * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.\n */\nexport function defineCustomEventTarget<\n    TEventMap extends Record<string, Event>,\n    TMode extends \"standard\" | \"strict\" = \"standard\"\n>(\n    ...types: (string & keyof TEventMap)[]\n): defineCustomEventTarget.CustomEventTargetConstructor<TEventMap, TMode> {\n    class CustomEventTarget extends EventTarget {}\n    for (let i = 0; i < types.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, types[i])\n    }\n\n    return CustomEventTarget as any\n}\n\nexport namespace defineCustomEventTarget {\n    /**\n     * The interface of CustomEventTarget constructor.\n     */\n    export type CustomEventTargetConstructor<\n        TEventMap extends Record<string, Event>,\n        TMode extends \"standard\" | \"strict\"\n    > = {\n        /**\n         * Create a new instance.\n         */\n        new (): CustomEventTarget<TEventMap, TMode>\n        /**\n         * prototype object.\n         */\n        prototype: CustomEventTarget<TEventMap, TMode>\n    }\n\n    /**\n     * The interface of CustomEventTarget.\n     */\n    export type CustomEventTarget<\n        TEventMap extends Record<string, Event>,\n        TMode extends \"standard\" | \"strict\"\n    > = EventTarget<TEventMap, TMode> &\n        defineEventAttribute.EventAttributes<any, TEventMap>\n}\n\n/**\n * Define an event attribute.\n * @param target The `EventTarget` object to define an event attribute.\n * @param type The event type to define.\n * @param _eventClass Unused, but to infer `Event` class type.\n * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.\n */\nexport function defineEventAttribute<\n    TEventTarget extends EventTarget,\n    TEventType extends string,\n    TEventConstrucor extends typeof Event\n>(\n    target: TEventTarget,\n    type: TEventType,\n    _eventClass?: TEventConstrucor,\n): asserts target is TEventTarget &\n    defineEventAttribute.EventAttributes<\n        TEventTarget,\n        Record<TEventType, InstanceType<TEventConstrucor>>\n    > {\n    Object.defineProperty(target, `on${type}`, {\n        get() {\n            return getEventAttributeValue(this, type)\n        },\n        set(value) {\n            setEventAttributeValue(this, type, value)\n        },\n        configurable: true,\n        enumerable: true,\n    })\n}\n\nexport namespace defineEventAttribute {\n    /**\n     * Definition of event attributes.\n     */\n    export type EventAttributes<\n        TEventTarget extends EventTarget<any, any>,\n        TEventMap extends Record<string, Event>\n    > = {\n        [P in string &\n            keyof TEventMap as `on${P}`]: EventTarget.CallbackFunction<\n            TEventTarget,\n            TEventMap[P]\n        > | null\n    }\n}\n"]},"metadata":{},"sourceType":"script"}
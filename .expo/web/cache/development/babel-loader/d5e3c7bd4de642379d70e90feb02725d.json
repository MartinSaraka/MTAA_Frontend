{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport { defineCustomEventTarget } from 'event-target-shim';\nimport { uniqueID } from \"./RTCUtil\";\nimport MediaStreamTrack from \"./MediaStreamTrack\";\nvar WebRTCModule = NativeModules.WebRTCModule;\nvar MEDIA_STREAM_EVENTS = ['active', 'inactive', 'addtrack', 'removetrack'];\n\nvar MediaStream = function (_defineCustomEventTar) {\n  _inherits(MediaStream, _defineCustomEventTar);\n\n  var _super = _createSuper(MediaStream);\n\n  function MediaStream(arg) {\n    var _this;\n\n    _classCallCheck(this, MediaStream);\n\n    _this = _super.call(this);\n\n    _defineProperty(_assertThisInitialized(_this), \"id\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"active\", true);\n\n    _defineProperty(_assertThisInitialized(_this), \"_tracks\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"_reactTag\", void 0);\n\n    _this.id = uniqueID();\n    _this._reactTag = _this.id;\n\n    if (typeof arg === 'undefined') {\n      WebRTCModule.mediaStreamCreate(_this.id);\n    } else if (arg instanceof MediaStream) {\n      WebRTCModule.mediaStreamCreate(_this.id);\n\n      for (var _iterator = _createForOfIteratorHelperLoose(arg.getTracks()), _step; !(_step = _iterator()).done;) {\n        var track = _step.value;\n\n        _this.addTrack(track);\n      }\n    } else if (Array.isArray(arg)) {\n      WebRTCModule.mediaStreamCreate(_this.id);\n\n      for (var _iterator2 = _createForOfIteratorHelperLoose(arg), _step2; !(_step2 = _iterator2()).done;) {\n        var _track = _step2.value;\n\n        _this.addTrack(_track);\n      }\n    } else if (typeof arg === 'object' && arg.streamId && arg.streamReactTag && arg.tracks) {\n      _this.id = arg.streamId;\n      _this._reactTag = arg.streamReactTag;\n\n      for (var _iterator3 = _createForOfIteratorHelperLoose(arg.tracks), _step3; !(_step3 = _iterator3()).done;) {\n        var trackInfo = _step3.value;\n\n        _this._tracks.push(new MediaStreamTrack(trackInfo));\n      }\n    } else {\n      throw new TypeError(\"invalid type: \" + typeof arg);\n    }\n\n    return _this;\n  }\n\n  _createClass(MediaStream, [{\n    key: \"addTrack\",\n    value: function addTrack(track) {\n      var index = this._tracks.indexOf(track);\n\n      if (index !== -1) {\n        return;\n      }\n\n      this._tracks.push(track);\n\n      WebRTCModule.mediaStreamAddTrack(this._reactTag, track.id);\n    }\n  }, {\n    key: \"removeTrack\",\n    value: function removeTrack(track) {\n      var index = this._tracks.indexOf(track);\n\n      if (index === -1) {\n        return;\n      }\n\n      this._tracks.splice(index, 1);\n\n      WebRTCModule.mediaStreamRemoveTrack(this._reactTag, track.id);\n    }\n  }, {\n    key: \"getTracks\",\n    value: function getTracks() {\n      return this._tracks.slice();\n    }\n  }, {\n    key: \"getTrackById\",\n    value: function getTrackById(trackId) {\n      return this._tracks.find(function (track) {\n        return track.id === trackId;\n      });\n    }\n  }, {\n    key: \"getAudioTracks\",\n    value: function getAudioTracks() {\n      return this._tracks.filter(function (track) {\n        return track.kind === 'audio';\n      });\n    }\n  }, {\n    key: \"getVideoTracks\",\n    value: function getVideoTracks() {\n      return this._tracks.filter(function (track) {\n        return track.kind === 'video';\n      });\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"toURL\",\n    value: function toURL() {\n      return this._reactTag;\n    }\n  }, {\n    key: \"release\",\n    value: function release() {\n      var releaseTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      var tracks = _toConsumableArray(this._tracks);\n\n      for (var _iterator4 = _createForOfIteratorHelperLoose(tracks), _step4; !(_step4 = _iterator4()).done;) {\n        var track = _step4.value;\n        this.removeTrack(track);\n\n        if (releaseTracks) {\n          track.release();\n        }\n      }\n\n      WebRTCModule.mediaStreamRelease(this._reactTag);\n    }\n  }]);\n\n  return MediaStream;\n}(defineCustomEventTarget.apply(void 0, MEDIA_STREAM_EVENTS));\n\nexport { MediaStream as default };","map":{"version":3,"sources":["MediaStream.ts"],"names":["WebRTCModule","MEDIA_STREAM_EVENTS","defineCustomEventTarget","constructor","uniqueID","arg","Array","addTrack","index","track","removeTrack","getTracks","getTrackById","getAudioTracks","getVideoTracks","clone","toURL","release","releaseTracks","tracks"],"mappings":"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","sourcesContent":["\nimport { NativeModules } from 'react-native';\nimport { defineCustomEventTarget } from 'event-target-shim';\nimport { uniqueID } from './RTCUtil';\n\nimport MediaStreamTrack from './MediaStreamTrack';\n\nconst { WebRTCModule } = NativeModules;\n\nconst MEDIA_STREAM_EVENTS = ['active', 'inactive', 'addtrack', 'removetrack'];\n\nexport default class MediaStream extends defineCustomEventTarget(...MEDIA_STREAM_EVENTS) {\n    id: string;\n    active: boolean = true;\n\n    _tracks: Array<MediaStreamTrack> = [];\n\n    /**\n     * The identifier of this MediaStream unique within the associated\n     * WebRTCModule instance. As the id of a remote MediaStream instance is unique\n     * only within the associated RTCPeerConnection, it is not sufficiently unique\n     * to identify this MediaStream across multiple RTCPeerConnections and to\n     * unambiguously differentiate it from a local MediaStream instance not added\n     * to an RTCPeerConnection.\n     */\n    _reactTag: string;\n\n    /**\n     * A MediaStream can be constructed in several ways, depending on the paramters\n     * that are passed here.\n     *\n     * - undefined: just a new stream, with no tracks.\n     * - MediaStream instance: a new stream, with a copy of the tracks of the passed stream.\n     * - Array of MediaStreamTrack: a new stream with a copy of the tracks in the array.\n     * - object: a new stream instance, represented by the passed info object, this is always\n     *   done internally, when the stream is first created in native and the JS wrapper is\n     *   built afterwards.\n     */\n    constructor(arg) {\n        super();\n\n        // Assigm a UUID to start with. It may get overridden for remote streams.\n        this.id = uniqueID();\n        // Local MediaStreams are created by WebRTCModule to have their id and\n        // reactTag equal because WebRTCModule follows the respective standard's\n        // recommendation for id generation i.e. uses UUID which is unique enough\n        // for the purposes of reactTag.\n        this._reactTag = this.id;\n\n        if (typeof arg === 'undefined') {\n            WebRTCModule.mediaStreamCreate(this.id);\n        } else if (arg instanceof MediaStream) {\n            WebRTCModule.mediaStreamCreate(this.id);\n            for (const track of arg.getTracks()) {\n                this.addTrack(track);\n            }\n        } else if (Array.isArray(arg)) {\n            WebRTCModule.mediaStreamCreate(this.id);\n            for (const track of arg) {\n                this.addTrack(track);\n            }\n        } else if (typeof arg === 'object' && arg.streamId && arg.streamReactTag && arg.tracks) {\n            this.id = arg.streamId;\n            this._reactTag = arg.streamReactTag;\n            for (const trackInfo of arg.tracks) {\n                // We are not using addTrack here because the track is already part of the\n                // stream, so there is no need to add it on the native side.\n                this._tracks.push(new MediaStreamTrack(trackInfo));\n            }\n        } else {\n            throw new TypeError(`invalid type: ${typeof arg}`);\n        }\n    }\n\n    addTrack(track: MediaStreamTrack) {\n        const index = this._tracks.indexOf(track);\n        if (index !== -1) {\n            return;\n        }\n        this._tracks.push(track);\n        WebRTCModule.mediaStreamAddTrack(this._reactTag, track.id);\n    }\n\n    removeTrack(track: MediaStreamTrack) {\n        const index = this._tracks.indexOf(track);\n        if (index === -1) {\n            return;\n        }\n        this._tracks.splice(index, 1);\n        WebRTCModule.mediaStreamRemoveTrack(this._reactTag, track.id);\n    }\n\n    getTracks(): Array<MediaStreamTrack> {\n        return this._tracks.slice();\n    }\n\n    getTrackById(trackId): MediaStreamTrack | undefined {\n        return this._tracks.find(track => track.id === trackId);\n    }\n\n    getAudioTracks(): Array<MediaStreamTrack> {\n        return this._tracks.filter(track => track.kind === 'audio');\n    }\n\n    getVideoTracks(): Array<MediaStreamTrack> {\n        return this._tracks.filter(track => track.kind === 'video');\n    }\n\n    clone() {\n        throw new Error('Not implemented.');\n    }\n\n    toURL() {\n        return this._reactTag;\n    }\n\n    release(releaseTracks = true) {\n        const tracks = [...this._tracks];\n        for (const track of tracks) {\n            this.removeTrack(track);\n            if (releaseTracks) {\n                track.release();\n            }\n        }\n\n        WebRTCModule.mediaStreamRelease(this._reactTag);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}
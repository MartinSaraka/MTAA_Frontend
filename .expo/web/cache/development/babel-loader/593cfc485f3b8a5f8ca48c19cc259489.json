{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport * as RTCUtil from \"./RTCUtil\";\nimport MediaStream from \"./MediaStream\";\nimport MediaStreamError from \"./MediaStreamError\";\nimport permissions from \"./Permissions\";\nvar WebRTCModule = NativeModules.WebRTCModule;\nexport default function getUserMedia() {\n  var constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (typeof constraints !== 'object') {\n    return Promise.reject(new TypeError('constraints is not a dictionary'));\n  }\n\n  if ((typeof constraints.audio === 'undefined' || !constraints.audio) && (typeof constraints.video === 'undefined' || !constraints.video)) {\n    return Promise.reject(new TypeError('audio and/or video is required'));\n  }\n\n  constraints = RTCUtil.normalizeConstraints(constraints);\n  var reqPermissions = [];\n\n  if (constraints.audio) {\n    reqPermissions.push(permissions.request({\n      name: 'microphone'\n    }));\n  } else {\n    reqPermissions.push(Promise.resolve(false));\n  }\n\n  if (constraints.video) {\n    reqPermissions.push(permissions.request({\n      name: 'camera'\n    }));\n  } else {\n    reqPermissions.push(Promise.resolve(false));\n  }\n\n  return new Promise(function (resolve, reject) {\n    Promise.all(reqPermissions).then(function (results) {\n      var _results = _slicedToArray(results, 2),\n          audioPerm = _results[0],\n          videoPerm = _results[1];\n\n      if (!audioPerm && !videoPerm) {\n        var error = {\n          message: 'Permission denied.',\n          name: 'SecurityError'\n        };\n        reject(new MediaStreamError(error));\n        return;\n      }\n\n      audioPerm || delete constraints.audio;\n      videoPerm || delete constraints.video;\n\n      var success = function success(id, tracks) {\n        for (var _iterator = _createForOfIteratorHelperLoose(tracks), _step; !(_step = _iterator()).done;) {\n          var trackInfo = _step.value;\n          var c = constraints[trackInfo.kind];\n\n          if (typeof c === 'object') {\n            trackInfo.constraints = RTCUtil.deepClone(c);\n          }\n        }\n\n        var info = {\n          streamId: id,\n          streamReactTag: id,\n          tracks: tracks\n        };\n        resolve(new MediaStream(info));\n      };\n\n      var failure = function failure(type, message) {\n        var error;\n\n        switch (type) {\n          case 'TypeError':\n            error = new TypeError(message);\n            break;\n        }\n\n        if (!error) {\n          error = new MediaStreamError({\n            message: message,\n            name: type\n          });\n        }\n\n        reject(error);\n      };\n\n      WebRTCModule.getUserMedia(constraints, success, failure);\n    });\n  });\n}","map":{"version":3,"sources":["getUserMedia.ts"],"names":["WebRTCModule","constraints","Promise","RTCUtil","reqPermissions","name","results","error","message","reject","audioPerm","videoPerm","success","c","trackInfo","info","streamId","streamReactTag","tracks","resolve","failure","type"],"mappings":"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","sourcesContent":["\nimport { NativeModules } from 'react-native';\nimport * as RTCUtil from './RTCUtil';\n\nimport MediaStream from './MediaStream';\nimport MediaStreamError from './MediaStreamError';\nimport permissions from './Permissions';\n\nconst { WebRTCModule } = NativeModules;\n\ninterface Constraints {\n    audio?: boolean | object;\n    video?: boolean | object;\n}\n\nexport default function getUserMedia(constraints: Constraints = {}) {\n    // According to\n    // https://www.w3.org/TR/mediacapture-streams/#dom-mediadevices-getusermedia,\n    // the constraints argument is a dictionary of type MediaStreamConstraints.\n    if (typeof constraints !== 'object') {\n        return Promise.reject(new TypeError('constraints is not a dictionary'));\n    }\n\n    if (\n        (typeof constraints.audio === 'undefined' || !constraints.audio) &&\n        (typeof constraints.video === 'undefined' || !constraints.video)\n    ) {\n        return Promise.reject(new TypeError('audio and/or video is required'));\n    }\n\n    // Normalize constraints.\n    constraints = RTCUtil.normalizeConstraints(constraints);\n\n    // Request required permissions\n    const reqPermissions: Array<Promise<boolean>> = [];\n    if (constraints.audio) {\n        reqPermissions.push(permissions.request({ name: 'microphone' }));\n    } else {\n        reqPermissions.push(Promise.resolve(false));\n    }\n    if (constraints.video) {\n        reqPermissions.push(permissions.request({ name: 'camera' }));\n    } else {\n        reqPermissions.push(Promise.resolve(false));\n    }\n\n    return new Promise((resolve, reject) => {\n        Promise.all(reqPermissions).then(results => {\n            const [audioPerm, videoPerm] = results;\n\n            // Check permission results and remove unneeded permissions.\n\n            if (!audioPerm && !videoPerm) {\n                // https://www.w3.org/TR/mediacapture-streams/#dom-mediadevices-getusermedia\n                // step 4\n                const error = {\n                    message: 'Permission denied.',\n                    name: 'SecurityError'\n                };\n                reject(new MediaStreamError(error));\n\n                return;\n            }\n\n            audioPerm || delete constraints.audio;\n            videoPerm || delete constraints.video;\n\n            const success = (id, tracks) => {\n                // Store initial constraints.\n                for (const trackInfo of tracks) {\n                    const c = constraints[trackInfo.kind];\n                    if (typeof c === 'object') {\n                        trackInfo.constraints = RTCUtil.deepClone(c);\n                    }\n                }\n\n                const info = {\n                    streamId: id,\n                    streamReactTag: id,\n                    tracks\n                };\n\n                resolve(new MediaStream(info));\n            };\n\n            const failure = (type, message) => {\n                let error;\n                switch (type) {\n                    case 'TypeError':\n                        error = new TypeError(message);\n                        break;\n                }\n                if (!error) {\n                    error = new MediaStreamError({ message, name: type });\n                }\n\n                reject(error);\n            };\n\n            WebRTCModule.getUserMedia(constraints, success, failure);\n        });\n    });\n}\n"]},"metadata":{},"sourceType":"module"}